Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ELLIPSIS
    OMG
    OMGWTF
    TROOF
    WTF

Grammar

Rule 0     S' -> program
Rule 1     program -> HAI FLOAT NEWLINE statements KTHXBYE
Rule 2     statements -> statements statement
Rule 3     statements -> statement
Rule 4     statement -> command NEWLINE
Rule 5     statement -> command COMMA
Rule 6     command -> empty
Rule 7     command -> expr
Rule 8     command -> call
Rule 9     command -> cast
Rule 10    command -> decl
Rule 11    command -> assign_bukkit
Rule 12    command -> assign
Rule 13    command -> declare_bukkit_block
Rule 14    command -> if_else
Rule 15    command -> bukkit_function
Rule 16    command -> function
Rule 17    command -> return
Rule 18    command -> loop
Rule 19    command -> export
Rule 20    command -> import
Rule 21    loop -> IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
Rule 22    operation -> UPPIN
Rule 23    operation -> NERFIN
Rule 24    condition -> TIL
Rule 25    condition -> WILE
Rule 26    import -> CAN HAS PATH QUESTION
Rule 27    import -> CAN HAS SNEK PATH QUESTION
Rule 28    export -> YOU CAN HAS sep_args MKAY
Rule 29    if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
Rule 30    if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
Rule 31    if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
Rule 32    elifs -> elifs elif
Rule 33    elifs -> elif
Rule 34    elif -> MEBBE expr NEWLINE statements
Rule 35    decl -> I HAS A variable
Rule 36    decl -> I HAS A variable ITZ expr
Rule 37    decl -> I HAS A variable ITZ A type
Rule 38    decl -> I HAS A variable ITZ LIEK A variable
Rule 39    declare_bukkit_block -> O HAI IM variable NEWLINE statements KTHX
Rule 40    assign_bukkit -> variable HAS A variable ITZ expr
Rule 41    assign -> variable R expr
Rule 42    expr -> variable APOSTROPHE_Z variable
Rule 43    cast -> variable IS NOW A type
Rule 44    cast -> variable R MAEK variable A type
Rule 45    cast -> variable R MAEK variable type
Rule 46    args -> args expr
Rule 47    args -> expr
Rule 48    sep_args -> sep_args AN expr
Rule 49    sep_args -> expr
Rule 50    sep_yr_args -> sep_yr_args AN YR expr
Rule 51    sep_yr_args -> expr
Rule 52    bukkit_function -> HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
Rule 53    bukkit_function -> HOW IZ variable ID NEWLINE statements IF U SAY SO
Rule 54    function -> HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
Rule 55    function -> HOW IZ I ID NEWLINE statements IF U SAY SO
Rule 56    expr -> I IZ ID YR sep_yr_args MKAY
Rule 57    expr -> I IZ ID
Rule 58    expr -> variable IZ ID YR sep_yr_args MKAY
Rule 59    expr -> variable IZ ID
Rule 60    return -> FOUND YR expr
Rule 61    return -> GTFO
Rule 62    type -> YARN
Rule 63    type -> NUMBR
Rule 64    type -> NUMBAR
Rule 65    type -> NOOB
Rule 66    type -> BUKKIT
Rule 67    value -> STRING
Rule 68    value -> FLOAT
Rule 69    value -> INTEGER
Rule 70    value -> WIN
Rule 71    value -> FAIL
Rule 72    value -> DICT
Rule 73    call -> VISIBLE args
Rule 74    call -> VISIBLE args EXCLAMATION
Rule 75    call -> GIMMEH variable
Rule 76    expr -> SIZE OF expr
Rule 77    expr -> ABSLUT OF expr
Rule 78    expr -> BINRY OF expr
Rule 79    expr -> expr YR BASE ARE BELONG TO expr
Rule 80    expr -> value
Rule 81    expr -> variable
Rule 82    expr -> SUM OF expr AN expr
Rule 83    expr -> DIFF OF expr AN expr
Rule 84    expr -> PRODUKT OF expr AN expr
Rule 85    expr -> QUOSHUNT OF expr AN expr
Rule 86    expr -> MOD OF expr AN expr
Rule 87    expr -> BIGGR OF expr AN expr
Rule 88    expr -> SMALLR OF expr AN expr
Rule 89    expr -> BOTH OF expr AN expr
Rule 90    expr -> EITHER OF expr AN expr
Rule 91    expr -> WON OF expr AN expr
Rule 92    expr -> NOT expr
Rule 93    expr -> ALL OF sep_args MKAY
Rule 94    expr -> ANY OF sep_args MKAY
Rule 95    expr -> ALL OF args MKAY
Rule 96    expr -> ANY OF args MKAY
Rule 97    expr -> BOTH SAEM expr AN expr
Rule 98    expr -> DIFFRINT expr AN expr
Rule 99    expr -> SMOOSH sep_args MKAY
Rule 100   expr -> SMOOSH args MKAY
Rule 101   expr -> MAEK expr A type
Rule 102   expr -> MAEK expr type
Rule 103   variable -> ID
Rule 104   variable -> IT
Rule 105   program -> error
Rule 106   empty -> <empty>

Terminals, with rules where they appear

A                    : 35 36 37 37 38 38 40 43 44 101
ABSLUT               : 77
ALL                  : 93 95
AN                   : 48 50 82 83 84 85 86 87 88 89 90 91 97 98
ANY                  : 94 96
APOSTROPHE_Z         : 42
ARE                  : 79
BASE                 : 79
BELONG               : 79
BIGGR                : 87
BINRY                : 78
BOTH                 : 89 97
BUKKIT               : 66
CAN                  : 26 27 28
COMMA                : 5
DICT                 : 72
DIFF                 : 83
DIFFRINT             : 98
EITHER               : 90
ELLIPSIS             : 
EXCLAMATION          : 74
FAIL                 : 71
FLOAT                : 1 68
FOUND                : 60
GIMMEH               : 75
GTFO                 : 61
HAI                  : 1 39
HAS                  : 26 27 28 35 36 37 38 40
HOW                  : 52 53 54 55
I                    : 35 36 37 38 54 55 56 57
ID                   : 52 53 54 55 56 57 58 59 103
IF                   : 52 53 54 55
IM                   : 21 21 39
IN                   : 21
INTEGER              : 69
IS                   : 43
IT                   : 104
ITZ                  : 36 37 38 40
IZ                   : 52 53 54 55 56 57 58 59
KTHX                 : 39
KTHXBYE              : 1
LIEK                 : 38
MAEK                 : 44 45 101 102
MEBBE                : 34
MKAY                 : 28 56 58 93 94 95 96 99 100
MOD                  : 86
NERFIN               : 23
NEWLINE              : 1 4 21 29 29 29 30 30 31 31 31 34 39 52 53 54 55
NO                   : 29 31
NOOB                 : 65
NOT                  : 92
NOW                  : 43
NUMBAR               : 64
NUMBR                : 63
O                    : 29 30 31 39
OF                   : 76 77 78 82 83 84 85 86 87 88 89 90 91 93 94 95 96
OIC                  : 29 30 31
OMG                  : 
OMGWTF               : 
OUTTA                : 21
PATH                 : 26 27
PRODUKT              : 84
QUESTION             : 26 27 29 30 31
QUOSHUNT             : 85
R                    : 41 44 45
RLY                  : 29 29 30 30 31 31
SAEM                 : 97
SAY                  : 52 53 54 55
SIZE                 : 76
SMALLR               : 88
SMOOSH               : 99 100
SNEK                 : 27
SO                   : 52 53 54 55
STRING               : 67
SUM                  : 82
TIL                  : 24
TO                   : 79
TROOF                : 
U                    : 52 53 54 55
UPPIN                : 22
VISIBLE              : 73 74
WAI                  : 29 31
WILE                 : 25
WIN                  : 70
WON                  : 91
WTF                  : 
YA                   : 29 30 31
YARN                 : 62
YOU                  : 28
YR                   : 21 21 21 50 52 54 56 58 60 79
error                : 105

Nonterminals, with rules where they appear

args                 : 46 73 74 95 96 100
assign               : 12
assign_bukkit        : 11
bukkit_function      : 15
call                 : 8
cast                 : 9
command              : 4 5
condition            : 21
decl                 : 10
declare_bukkit_block : 13
elif                 : 32 33
elifs                : 31 32
empty                : 6
export               : 19
expr                 : 7 21 34 36 40 41 46 47 48 49 50 51 60 76 77 78 79 79 82 82 83 83 84 84 85 85 86 86 87 87 88 88 89 89 90 90 91 91 92 97 97 98 98 101 102
function             : 16
if_else              : 14
import               : 20
loop                 : 18
operation            : 21
program              : 0
return               : 17
sep_args             : 28 48 93 94 99
sep_yr_args          : 50 52 54 56 58
statement            : 2 3
statements           : 1 2 21 29 29 30 31 31 34 39 52 53 54 55
type                 : 37 43 44 45 101 102
value                : 80
variable             : 21 21 21 35 36 37 38 38 39 40 40 41 42 42 43 44 44 45 45 52 53 58 59 75 81

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . HAI FLOAT NEWLINE statements KTHXBYE
    (105) program -> . error

    HAI             shift and go to state 2
    error           shift and go to state 3

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> HAI . FLOAT NEWLINE statements KTHXBYE

    FLOAT           shift and go to state 4


state 3

    (105) program -> error .

    $end            reduce using rule 105 (program -> error .)


state 4

    (1) program -> HAI FLOAT . NEWLINE statements KTHXBYE

    NEWLINE         shift and go to state 5


state 5

    (1) program -> HAI FLOAT NEWLINE . statements KTHXBYE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    statements                     shift and go to state 7
    statement                      shift and go to state 8
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 6

    (68) value -> FLOAT .

    YR              reduce using rule 68 (value -> FLOAT .)
    NEWLINE         reduce using rule 68 (value -> FLOAT .)
    COMMA           reduce using rule 68 (value -> FLOAT .)
    AN              reduce using rule 68 (value -> FLOAT .)
    MKAY            reduce using rule 68 (value -> FLOAT .)
    I               reduce using rule 68 (value -> FLOAT .)
    SIZE            reduce using rule 68 (value -> FLOAT .)
    ABSLUT          reduce using rule 68 (value -> FLOAT .)
    BINRY           reduce using rule 68 (value -> FLOAT .)
    SUM             reduce using rule 68 (value -> FLOAT .)
    DIFF            reduce using rule 68 (value -> FLOAT .)
    PRODUKT         reduce using rule 68 (value -> FLOAT .)
    QUOSHUNT        reduce using rule 68 (value -> FLOAT .)
    MOD             reduce using rule 68 (value -> FLOAT .)
    BIGGR           reduce using rule 68 (value -> FLOAT .)
    SMALLR          reduce using rule 68 (value -> FLOAT .)
    BOTH            reduce using rule 68 (value -> FLOAT .)
    EITHER          reduce using rule 68 (value -> FLOAT .)
    WON             reduce using rule 68 (value -> FLOAT .)
    NOT             reduce using rule 68 (value -> FLOAT .)
    ALL             reduce using rule 68 (value -> FLOAT .)
    ANY             reduce using rule 68 (value -> FLOAT .)
    DIFFRINT        reduce using rule 68 (value -> FLOAT .)
    SMOOSH          reduce using rule 68 (value -> FLOAT .)
    MAEK            reduce using rule 68 (value -> FLOAT .)
    ID              reduce using rule 68 (value -> FLOAT .)
    IT              reduce using rule 68 (value -> FLOAT .)
    STRING          reduce using rule 68 (value -> FLOAT .)
    FLOAT           reduce using rule 68 (value -> FLOAT .)
    INTEGER         reduce using rule 68 (value -> FLOAT .)
    WIN             reduce using rule 68 (value -> FLOAT .)
    FAIL            reduce using rule 68 (value -> FLOAT .)
    DICT            reduce using rule 68 (value -> FLOAT .)
    A               reduce using rule 68 (value -> FLOAT .)
    YARN            reduce using rule 68 (value -> FLOAT .)
    NUMBR           reduce using rule 68 (value -> FLOAT .)
    NUMBAR          reduce using rule 68 (value -> FLOAT .)
    NOOB            reduce using rule 68 (value -> FLOAT .)
    BUKKIT          reduce using rule 68 (value -> FLOAT .)
    EXCLAMATION     reduce using rule 68 (value -> FLOAT .)


state 7

    (1) program -> HAI FLOAT NEWLINE statements . KTHXBYE
    (2) statements -> statements . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    KTHXBYE         shift and go to state 63
    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    statement                      shift and go to state 64
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 8

    (3) statements -> statement .

    KTHXBYE         reduce using rule 3 (statements -> statement .)
    I               reduce using rule 3 (statements -> statement .)
    SIZE            reduce using rule 3 (statements -> statement .)
    ABSLUT          reduce using rule 3 (statements -> statement .)
    BINRY           reduce using rule 3 (statements -> statement .)
    SUM             reduce using rule 3 (statements -> statement .)
    DIFF            reduce using rule 3 (statements -> statement .)
    PRODUKT         reduce using rule 3 (statements -> statement .)
    QUOSHUNT        reduce using rule 3 (statements -> statement .)
    MOD             reduce using rule 3 (statements -> statement .)
    BIGGR           reduce using rule 3 (statements -> statement .)
    SMALLR          reduce using rule 3 (statements -> statement .)
    BOTH            reduce using rule 3 (statements -> statement .)
    EITHER          reduce using rule 3 (statements -> statement .)
    WON             reduce using rule 3 (statements -> statement .)
    NOT             reduce using rule 3 (statements -> statement .)
    ALL             reduce using rule 3 (statements -> statement .)
    ANY             reduce using rule 3 (statements -> statement .)
    DIFFRINT        reduce using rule 3 (statements -> statement .)
    SMOOSH          reduce using rule 3 (statements -> statement .)
    MAEK            reduce using rule 3 (statements -> statement .)
    VISIBLE         reduce using rule 3 (statements -> statement .)
    GIMMEH          reduce using rule 3 (statements -> statement .)
    O               reduce using rule 3 (statements -> statement .)
    HOW             reduce using rule 3 (statements -> statement .)
    FOUND           reduce using rule 3 (statements -> statement .)
    GTFO            reduce using rule 3 (statements -> statement .)
    IM              reduce using rule 3 (statements -> statement .)
    YOU             reduce using rule 3 (statements -> statement .)
    CAN             reduce using rule 3 (statements -> statement .)
    ID              reduce using rule 3 (statements -> statement .)
    IT              reduce using rule 3 (statements -> statement .)
    STRING          reduce using rule 3 (statements -> statement .)
    FLOAT           reduce using rule 3 (statements -> statement .)
    INTEGER         reduce using rule 3 (statements -> statement .)
    WIN             reduce using rule 3 (statements -> statement .)
    FAIL            reduce using rule 3 (statements -> statement .)
    DICT            reduce using rule 3 (statements -> statement .)
    NEWLINE         reduce using rule 3 (statements -> statement .)
    COMMA           reduce using rule 3 (statements -> statement .)
    KTHX            reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    NO              reduce using rule 3 (statements -> statement .)
    OIC             reduce using rule 3 (statements -> statement .)
    MEBBE           reduce using rule 3 (statements -> statement .)


state 9

    (4) statement -> command . NEWLINE
    (5) statement -> command . COMMA

    NEWLINE         shift and go to state 65
    COMMA           shift and go to state 66


state 10

    (6) command -> empty .

    NEWLINE         reduce using rule 6 (command -> empty .)
    COMMA           reduce using rule 6 (command -> empty .)


state 11

    (7) command -> expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    NEWLINE         reduce using rule 7 (command -> expr .)
    COMMA           reduce using rule 7 (command -> expr .)
    YR              shift and go to state 67


state 12

    (8) command -> call .

    NEWLINE         reduce using rule 8 (command -> call .)
    COMMA           reduce using rule 8 (command -> call .)


state 13

    (9) command -> cast .

    NEWLINE         reduce using rule 9 (command -> cast .)
    COMMA           reduce using rule 9 (command -> cast .)


state 14

    (10) command -> decl .

    NEWLINE         reduce using rule 10 (command -> decl .)
    COMMA           reduce using rule 10 (command -> decl .)


state 15

    (11) command -> assign_bukkit .

    NEWLINE         reduce using rule 11 (command -> assign_bukkit .)
    COMMA           reduce using rule 11 (command -> assign_bukkit .)


state 16

    (12) command -> assign .

    NEWLINE         reduce using rule 12 (command -> assign .)
    COMMA           reduce using rule 12 (command -> assign .)


state 17

    (13) command -> declare_bukkit_block .

    NEWLINE         reduce using rule 13 (command -> declare_bukkit_block .)
    COMMA           reduce using rule 13 (command -> declare_bukkit_block .)


state 18

    (14) command -> if_else .

    NEWLINE         reduce using rule 14 (command -> if_else .)
    COMMA           reduce using rule 14 (command -> if_else .)


state 19

    (15) command -> bukkit_function .

    NEWLINE         reduce using rule 15 (command -> bukkit_function .)
    COMMA           reduce using rule 15 (command -> bukkit_function .)


state 20

    (16) command -> function .

    NEWLINE         reduce using rule 16 (command -> function .)
    COMMA           reduce using rule 16 (command -> function .)


state 21

    (17) command -> return .

    NEWLINE         reduce using rule 17 (command -> return .)
    COMMA           reduce using rule 17 (command -> return .)


state 22

    (18) command -> loop .

    NEWLINE         reduce using rule 18 (command -> loop .)
    COMMA           reduce using rule 18 (command -> loop .)


state 23

    (19) command -> export .

    NEWLINE         reduce using rule 19 (command -> export .)
    COMMA           reduce using rule 19 (command -> export .)


state 24

    (20) command -> import .

    NEWLINE         reduce using rule 20 (command -> import .)
    COMMA           reduce using rule 20 (command -> import .)


state 25

    (42) expr -> variable . APOSTROPHE_Z variable
    (58) expr -> variable . IZ ID YR sep_yr_args MKAY
    (59) expr -> variable . IZ ID
    (81) expr -> variable .
    (43) cast -> variable . IS NOW A type
    (44) cast -> variable . R MAEK variable A type
    (45) cast -> variable . R MAEK variable type
    (40) assign_bukkit -> variable . HAS A variable ITZ expr
    (41) assign -> variable . R expr

    APOSTROPHE_Z    shift and go to state 68
    IZ              shift and go to state 69
    YR              reduce using rule 81 (expr -> variable .)
    NEWLINE         reduce using rule 81 (expr -> variable .)
    COMMA           reduce using rule 81 (expr -> variable .)
    IS              shift and go to state 70
    R               shift and go to state 71
    HAS             shift and go to state 72


state 26

    (56) expr -> I . IZ ID YR sep_yr_args MKAY
    (57) expr -> I . IZ ID
    (35) decl -> I . HAS A variable
    (36) decl -> I . HAS A variable ITZ expr
    (37) decl -> I . HAS A variable ITZ A type
    (38) decl -> I . HAS A variable ITZ LIEK A variable

    IZ              shift and go to state 73
    HAS             shift and go to state 74


state 27

    (103) variable -> ID .

    APOSTROPHE_Z    reduce using rule 103 (variable -> ID .)
    IZ              reduce using rule 103 (variable -> ID .)
    IS              reduce using rule 103 (variable -> ID .)
    R               reduce using rule 103 (variable -> ID .)
    HAS             reduce using rule 103 (variable -> ID .)
    YR              reduce using rule 103 (variable -> ID .)
    NEWLINE         reduce using rule 103 (variable -> ID .)
    COMMA           reduce using rule 103 (variable -> ID .)
    AN              reduce using rule 103 (variable -> ID .)
    MKAY            reduce using rule 103 (variable -> ID .)
    I               reduce using rule 103 (variable -> ID .)
    SIZE            reduce using rule 103 (variable -> ID .)
    ABSLUT          reduce using rule 103 (variable -> ID .)
    BINRY           reduce using rule 103 (variable -> ID .)
    SUM             reduce using rule 103 (variable -> ID .)
    DIFF            reduce using rule 103 (variable -> ID .)
    PRODUKT         reduce using rule 103 (variable -> ID .)
    QUOSHUNT        reduce using rule 103 (variable -> ID .)
    MOD             reduce using rule 103 (variable -> ID .)
    BIGGR           reduce using rule 103 (variable -> ID .)
    SMALLR          reduce using rule 103 (variable -> ID .)
    BOTH            reduce using rule 103 (variable -> ID .)
    EITHER          reduce using rule 103 (variable -> ID .)
    WON             reduce using rule 103 (variable -> ID .)
    NOT             reduce using rule 103 (variable -> ID .)
    ALL             reduce using rule 103 (variable -> ID .)
    ANY             reduce using rule 103 (variable -> ID .)
    DIFFRINT        reduce using rule 103 (variable -> ID .)
    SMOOSH          reduce using rule 103 (variable -> ID .)
    MAEK            reduce using rule 103 (variable -> ID .)
    ID              reduce using rule 103 (variable -> ID .)
    IT              reduce using rule 103 (variable -> ID .)
    STRING          reduce using rule 103 (variable -> ID .)
    FLOAT           reduce using rule 103 (variable -> ID .)
    INTEGER         reduce using rule 103 (variable -> ID .)
    WIN             reduce using rule 103 (variable -> ID .)
    FAIL            reduce using rule 103 (variable -> ID .)
    DICT            reduce using rule 103 (variable -> ID .)
    A               reduce using rule 103 (variable -> ID .)
    YARN            reduce using rule 103 (variable -> ID .)
    NUMBR           reduce using rule 103 (variable -> ID .)
    NUMBAR          reduce using rule 103 (variable -> ID .)
    NOOB            reduce using rule 103 (variable -> ID .)
    BUKKIT          reduce using rule 103 (variable -> ID .)
    EXCLAMATION     reduce using rule 103 (variable -> ID .)
    ITZ             reduce using rule 103 (variable -> ID .)
    UPPIN           reduce using rule 103 (variable -> ID .)
    NERFIN          reduce using rule 103 (variable -> ID .)
    TIL             reduce using rule 103 (variable -> ID .)
    WILE            reduce using rule 103 (variable -> ID .)


state 28

    (76) expr -> SIZE . OF expr

    OF              shift and go to state 75


state 29

    (77) expr -> ABSLUT . OF expr

    OF              shift and go to state 76


state 30

    (78) expr -> BINRY . OF expr

    OF              shift and go to state 77


state 31

    (80) expr -> value .

    YR              reduce using rule 80 (expr -> value .)
    NEWLINE         reduce using rule 80 (expr -> value .)
    COMMA           reduce using rule 80 (expr -> value .)
    AN              reduce using rule 80 (expr -> value .)
    MKAY            reduce using rule 80 (expr -> value .)
    I               reduce using rule 80 (expr -> value .)
    SIZE            reduce using rule 80 (expr -> value .)
    ABSLUT          reduce using rule 80 (expr -> value .)
    BINRY           reduce using rule 80 (expr -> value .)
    SUM             reduce using rule 80 (expr -> value .)
    DIFF            reduce using rule 80 (expr -> value .)
    PRODUKT         reduce using rule 80 (expr -> value .)
    QUOSHUNT        reduce using rule 80 (expr -> value .)
    MOD             reduce using rule 80 (expr -> value .)
    BIGGR           reduce using rule 80 (expr -> value .)
    SMALLR          reduce using rule 80 (expr -> value .)
    BOTH            reduce using rule 80 (expr -> value .)
    EITHER          reduce using rule 80 (expr -> value .)
    WON             reduce using rule 80 (expr -> value .)
    NOT             reduce using rule 80 (expr -> value .)
    ALL             reduce using rule 80 (expr -> value .)
    ANY             reduce using rule 80 (expr -> value .)
    DIFFRINT        reduce using rule 80 (expr -> value .)
    SMOOSH          reduce using rule 80 (expr -> value .)
    MAEK            reduce using rule 80 (expr -> value .)
    ID              reduce using rule 80 (expr -> value .)
    IT              reduce using rule 80 (expr -> value .)
    STRING          reduce using rule 80 (expr -> value .)
    FLOAT           reduce using rule 80 (expr -> value .)
    INTEGER         reduce using rule 80 (expr -> value .)
    WIN             reduce using rule 80 (expr -> value .)
    FAIL            reduce using rule 80 (expr -> value .)
    DICT            reduce using rule 80 (expr -> value .)
    A               reduce using rule 80 (expr -> value .)
    YARN            reduce using rule 80 (expr -> value .)
    NUMBR           reduce using rule 80 (expr -> value .)
    NUMBAR          reduce using rule 80 (expr -> value .)
    NOOB            reduce using rule 80 (expr -> value .)
    BUKKIT          reduce using rule 80 (expr -> value .)
    EXCLAMATION     reduce using rule 80 (expr -> value .)


state 32

    (82) expr -> SUM . OF expr AN expr

    OF              shift and go to state 78


state 33

    (83) expr -> DIFF . OF expr AN expr

    OF              shift and go to state 79


state 34

    (84) expr -> PRODUKT . OF expr AN expr

    OF              shift and go to state 80


state 35

    (85) expr -> QUOSHUNT . OF expr AN expr

    OF              shift and go to state 81


state 36

    (86) expr -> MOD . OF expr AN expr

    OF              shift and go to state 82


state 37

    (87) expr -> BIGGR . OF expr AN expr

    OF              shift and go to state 83


state 38

    (88) expr -> SMALLR . OF expr AN expr

    OF              shift and go to state 84


state 39

    (89) expr -> BOTH . OF expr AN expr
    (97) expr -> BOTH . SAEM expr AN expr

    OF              shift and go to state 85
    SAEM            shift and go to state 86


state 40

    (90) expr -> EITHER . OF expr AN expr

    OF              shift and go to state 87


state 41

    (91) expr -> WON . OF expr AN expr

    OF              shift and go to state 88


state 42

    (92) expr -> NOT . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 89
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 43

    (93) expr -> ALL . OF sep_args MKAY
    (95) expr -> ALL . OF args MKAY

    OF              shift and go to state 92


state 44

    (94) expr -> ANY . OF sep_args MKAY
    (96) expr -> ANY . OF args MKAY

    OF              shift and go to state 93


state 45

    (98) expr -> DIFFRINT . expr AN expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 94
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 46

    (99) expr -> SMOOSH . sep_args MKAY
    (100) expr -> SMOOSH . args MKAY
    (48) sep_args -> . sep_args AN expr
    (49) sep_args -> . expr
    (46) args -> . args expr
    (47) args -> . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    sep_args                       shift and go to state 95
    args                           shift and go to state 96
    expr                           shift and go to state 97
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 47

    (101) expr -> MAEK . expr A type
    (102) expr -> MAEK . expr type
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 98
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 48

    (73) call -> VISIBLE . args
    (74) call -> VISIBLE . args EXCLAMATION
    (46) args -> . args expr
    (47) args -> . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    args                           shift and go to state 99
    expr                           shift and go to state 100
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 49

    (75) call -> GIMMEH . variable
    (103) variable -> . ID
    (104) variable -> . IT

    ID              shift and go to state 27
    IT              shift and go to state 57

    variable                       shift and go to state 101

state 50

    (39) declare_bukkit_block -> O . HAI IM variable NEWLINE statements KTHX
    (29) if_else -> O . RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> O . RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> O . RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC

    HAI             shift and go to state 102
    RLY             shift and go to state 103


state 51

    (21) loop -> IM . IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable

    IN              shift and go to state 104


state 52

    (52) bukkit_function -> HOW . IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> HOW . IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> HOW . IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> HOW . IZ I ID NEWLINE statements IF U SAY SO

    IZ              shift and go to state 105


state 53

    (60) return -> FOUND . YR expr

    YR              shift and go to state 106


state 54

    (61) return -> GTFO .

    NEWLINE         reduce using rule 61 (return -> GTFO .)
    COMMA           reduce using rule 61 (return -> GTFO .)


state 55

    (28) export -> YOU . CAN HAS sep_args MKAY

    CAN             shift and go to state 107


state 56

    (26) import -> CAN . HAS PATH QUESTION
    (27) import -> CAN . HAS SNEK PATH QUESTION

    HAS             shift and go to state 108


state 57

    (104) variable -> IT .

    APOSTROPHE_Z    reduce using rule 104 (variable -> IT .)
    IZ              reduce using rule 104 (variable -> IT .)
    IS              reduce using rule 104 (variable -> IT .)
    R               reduce using rule 104 (variable -> IT .)
    HAS             reduce using rule 104 (variable -> IT .)
    YR              reduce using rule 104 (variable -> IT .)
    NEWLINE         reduce using rule 104 (variable -> IT .)
    COMMA           reduce using rule 104 (variable -> IT .)
    AN              reduce using rule 104 (variable -> IT .)
    MKAY            reduce using rule 104 (variable -> IT .)
    I               reduce using rule 104 (variable -> IT .)
    SIZE            reduce using rule 104 (variable -> IT .)
    ABSLUT          reduce using rule 104 (variable -> IT .)
    BINRY           reduce using rule 104 (variable -> IT .)
    SUM             reduce using rule 104 (variable -> IT .)
    DIFF            reduce using rule 104 (variable -> IT .)
    PRODUKT         reduce using rule 104 (variable -> IT .)
    QUOSHUNT        reduce using rule 104 (variable -> IT .)
    MOD             reduce using rule 104 (variable -> IT .)
    BIGGR           reduce using rule 104 (variable -> IT .)
    SMALLR          reduce using rule 104 (variable -> IT .)
    BOTH            reduce using rule 104 (variable -> IT .)
    EITHER          reduce using rule 104 (variable -> IT .)
    WON             reduce using rule 104 (variable -> IT .)
    NOT             reduce using rule 104 (variable -> IT .)
    ALL             reduce using rule 104 (variable -> IT .)
    ANY             reduce using rule 104 (variable -> IT .)
    DIFFRINT        reduce using rule 104 (variable -> IT .)
    SMOOSH          reduce using rule 104 (variable -> IT .)
    MAEK            reduce using rule 104 (variable -> IT .)
    ID              reduce using rule 104 (variable -> IT .)
    IT              reduce using rule 104 (variable -> IT .)
    STRING          reduce using rule 104 (variable -> IT .)
    FLOAT           reduce using rule 104 (variable -> IT .)
    INTEGER         reduce using rule 104 (variable -> IT .)
    WIN             reduce using rule 104 (variable -> IT .)
    FAIL            reduce using rule 104 (variable -> IT .)
    DICT            reduce using rule 104 (variable -> IT .)
    A               reduce using rule 104 (variable -> IT .)
    YARN            reduce using rule 104 (variable -> IT .)
    NUMBR           reduce using rule 104 (variable -> IT .)
    NUMBAR          reduce using rule 104 (variable -> IT .)
    NOOB            reduce using rule 104 (variable -> IT .)
    BUKKIT          reduce using rule 104 (variable -> IT .)
    EXCLAMATION     reduce using rule 104 (variable -> IT .)
    ITZ             reduce using rule 104 (variable -> IT .)
    UPPIN           reduce using rule 104 (variable -> IT .)
    NERFIN          reduce using rule 104 (variable -> IT .)
    TIL             reduce using rule 104 (variable -> IT .)
    WILE            reduce using rule 104 (variable -> IT .)


state 58

    (67) value -> STRING .

    YR              reduce using rule 67 (value -> STRING .)
    NEWLINE         reduce using rule 67 (value -> STRING .)
    COMMA           reduce using rule 67 (value -> STRING .)
    AN              reduce using rule 67 (value -> STRING .)
    MKAY            reduce using rule 67 (value -> STRING .)
    I               reduce using rule 67 (value -> STRING .)
    SIZE            reduce using rule 67 (value -> STRING .)
    ABSLUT          reduce using rule 67 (value -> STRING .)
    BINRY           reduce using rule 67 (value -> STRING .)
    SUM             reduce using rule 67 (value -> STRING .)
    DIFF            reduce using rule 67 (value -> STRING .)
    PRODUKT         reduce using rule 67 (value -> STRING .)
    QUOSHUNT        reduce using rule 67 (value -> STRING .)
    MOD             reduce using rule 67 (value -> STRING .)
    BIGGR           reduce using rule 67 (value -> STRING .)
    SMALLR          reduce using rule 67 (value -> STRING .)
    BOTH            reduce using rule 67 (value -> STRING .)
    EITHER          reduce using rule 67 (value -> STRING .)
    WON             reduce using rule 67 (value -> STRING .)
    NOT             reduce using rule 67 (value -> STRING .)
    ALL             reduce using rule 67 (value -> STRING .)
    ANY             reduce using rule 67 (value -> STRING .)
    DIFFRINT        reduce using rule 67 (value -> STRING .)
    SMOOSH          reduce using rule 67 (value -> STRING .)
    MAEK            reduce using rule 67 (value -> STRING .)
    ID              reduce using rule 67 (value -> STRING .)
    IT              reduce using rule 67 (value -> STRING .)
    STRING          reduce using rule 67 (value -> STRING .)
    FLOAT           reduce using rule 67 (value -> STRING .)
    INTEGER         reduce using rule 67 (value -> STRING .)
    WIN             reduce using rule 67 (value -> STRING .)
    FAIL            reduce using rule 67 (value -> STRING .)
    DICT            reduce using rule 67 (value -> STRING .)
    A               reduce using rule 67 (value -> STRING .)
    YARN            reduce using rule 67 (value -> STRING .)
    NUMBR           reduce using rule 67 (value -> STRING .)
    NUMBAR          reduce using rule 67 (value -> STRING .)
    NOOB            reduce using rule 67 (value -> STRING .)
    BUKKIT          reduce using rule 67 (value -> STRING .)
    EXCLAMATION     reduce using rule 67 (value -> STRING .)


state 59

    (69) value -> INTEGER .

    YR              reduce using rule 69 (value -> INTEGER .)
    NEWLINE         reduce using rule 69 (value -> INTEGER .)
    COMMA           reduce using rule 69 (value -> INTEGER .)
    AN              reduce using rule 69 (value -> INTEGER .)
    MKAY            reduce using rule 69 (value -> INTEGER .)
    I               reduce using rule 69 (value -> INTEGER .)
    SIZE            reduce using rule 69 (value -> INTEGER .)
    ABSLUT          reduce using rule 69 (value -> INTEGER .)
    BINRY           reduce using rule 69 (value -> INTEGER .)
    SUM             reduce using rule 69 (value -> INTEGER .)
    DIFF            reduce using rule 69 (value -> INTEGER .)
    PRODUKT         reduce using rule 69 (value -> INTEGER .)
    QUOSHUNT        reduce using rule 69 (value -> INTEGER .)
    MOD             reduce using rule 69 (value -> INTEGER .)
    BIGGR           reduce using rule 69 (value -> INTEGER .)
    SMALLR          reduce using rule 69 (value -> INTEGER .)
    BOTH            reduce using rule 69 (value -> INTEGER .)
    EITHER          reduce using rule 69 (value -> INTEGER .)
    WON             reduce using rule 69 (value -> INTEGER .)
    NOT             reduce using rule 69 (value -> INTEGER .)
    ALL             reduce using rule 69 (value -> INTEGER .)
    ANY             reduce using rule 69 (value -> INTEGER .)
    DIFFRINT        reduce using rule 69 (value -> INTEGER .)
    SMOOSH          reduce using rule 69 (value -> INTEGER .)
    MAEK            reduce using rule 69 (value -> INTEGER .)
    ID              reduce using rule 69 (value -> INTEGER .)
    IT              reduce using rule 69 (value -> INTEGER .)
    STRING          reduce using rule 69 (value -> INTEGER .)
    FLOAT           reduce using rule 69 (value -> INTEGER .)
    INTEGER         reduce using rule 69 (value -> INTEGER .)
    WIN             reduce using rule 69 (value -> INTEGER .)
    FAIL            reduce using rule 69 (value -> INTEGER .)
    DICT            reduce using rule 69 (value -> INTEGER .)
    A               reduce using rule 69 (value -> INTEGER .)
    YARN            reduce using rule 69 (value -> INTEGER .)
    NUMBR           reduce using rule 69 (value -> INTEGER .)
    NUMBAR          reduce using rule 69 (value -> INTEGER .)
    NOOB            reduce using rule 69 (value -> INTEGER .)
    BUKKIT          reduce using rule 69 (value -> INTEGER .)
    EXCLAMATION     reduce using rule 69 (value -> INTEGER .)


state 60

    (70) value -> WIN .

    YR              reduce using rule 70 (value -> WIN .)
    NEWLINE         reduce using rule 70 (value -> WIN .)
    COMMA           reduce using rule 70 (value -> WIN .)
    AN              reduce using rule 70 (value -> WIN .)
    MKAY            reduce using rule 70 (value -> WIN .)
    I               reduce using rule 70 (value -> WIN .)
    SIZE            reduce using rule 70 (value -> WIN .)
    ABSLUT          reduce using rule 70 (value -> WIN .)
    BINRY           reduce using rule 70 (value -> WIN .)
    SUM             reduce using rule 70 (value -> WIN .)
    DIFF            reduce using rule 70 (value -> WIN .)
    PRODUKT         reduce using rule 70 (value -> WIN .)
    QUOSHUNT        reduce using rule 70 (value -> WIN .)
    MOD             reduce using rule 70 (value -> WIN .)
    BIGGR           reduce using rule 70 (value -> WIN .)
    SMALLR          reduce using rule 70 (value -> WIN .)
    BOTH            reduce using rule 70 (value -> WIN .)
    EITHER          reduce using rule 70 (value -> WIN .)
    WON             reduce using rule 70 (value -> WIN .)
    NOT             reduce using rule 70 (value -> WIN .)
    ALL             reduce using rule 70 (value -> WIN .)
    ANY             reduce using rule 70 (value -> WIN .)
    DIFFRINT        reduce using rule 70 (value -> WIN .)
    SMOOSH          reduce using rule 70 (value -> WIN .)
    MAEK            reduce using rule 70 (value -> WIN .)
    ID              reduce using rule 70 (value -> WIN .)
    IT              reduce using rule 70 (value -> WIN .)
    STRING          reduce using rule 70 (value -> WIN .)
    FLOAT           reduce using rule 70 (value -> WIN .)
    INTEGER         reduce using rule 70 (value -> WIN .)
    WIN             reduce using rule 70 (value -> WIN .)
    FAIL            reduce using rule 70 (value -> WIN .)
    DICT            reduce using rule 70 (value -> WIN .)
    A               reduce using rule 70 (value -> WIN .)
    YARN            reduce using rule 70 (value -> WIN .)
    NUMBR           reduce using rule 70 (value -> WIN .)
    NUMBAR          reduce using rule 70 (value -> WIN .)
    NOOB            reduce using rule 70 (value -> WIN .)
    BUKKIT          reduce using rule 70 (value -> WIN .)
    EXCLAMATION     reduce using rule 70 (value -> WIN .)


state 61

    (71) value -> FAIL .

    YR              reduce using rule 71 (value -> FAIL .)
    NEWLINE         reduce using rule 71 (value -> FAIL .)
    COMMA           reduce using rule 71 (value -> FAIL .)
    AN              reduce using rule 71 (value -> FAIL .)
    MKAY            reduce using rule 71 (value -> FAIL .)
    I               reduce using rule 71 (value -> FAIL .)
    SIZE            reduce using rule 71 (value -> FAIL .)
    ABSLUT          reduce using rule 71 (value -> FAIL .)
    BINRY           reduce using rule 71 (value -> FAIL .)
    SUM             reduce using rule 71 (value -> FAIL .)
    DIFF            reduce using rule 71 (value -> FAIL .)
    PRODUKT         reduce using rule 71 (value -> FAIL .)
    QUOSHUNT        reduce using rule 71 (value -> FAIL .)
    MOD             reduce using rule 71 (value -> FAIL .)
    BIGGR           reduce using rule 71 (value -> FAIL .)
    SMALLR          reduce using rule 71 (value -> FAIL .)
    BOTH            reduce using rule 71 (value -> FAIL .)
    EITHER          reduce using rule 71 (value -> FAIL .)
    WON             reduce using rule 71 (value -> FAIL .)
    NOT             reduce using rule 71 (value -> FAIL .)
    ALL             reduce using rule 71 (value -> FAIL .)
    ANY             reduce using rule 71 (value -> FAIL .)
    DIFFRINT        reduce using rule 71 (value -> FAIL .)
    SMOOSH          reduce using rule 71 (value -> FAIL .)
    MAEK            reduce using rule 71 (value -> FAIL .)
    ID              reduce using rule 71 (value -> FAIL .)
    IT              reduce using rule 71 (value -> FAIL .)
    STRING          reduce using rule 71 (value -> FAIL .)
    FLOAT           reduce using rule 71 (value -> FAIL .)
    INTEGER         reduce using rule 71 (value -> FAIL .)
    WIN             reduce using rule 71 (value -> FAIL .)
    FAIL            reduce using rule 71 (value -> FAIL .)
    DICT            reduce using rule 71 (value -> FAIL .)
    A               reduce using rule 71 (value -> FAIL .)
    YARN            reduce using rule 71 (value -> FAIL .)
    NUMBR           reduce using rule 71 (value -> FAIL .)
    NUMBAR          reduce using rule 71 (value -> FAIL .)
    NOOB            reduce using rule 71 (value -> FAIL .)
    BUKKIT          reduce using rule 71 (value -> FAIL .)
    EXCLAMATION     reduce using rule 71 (value -> FAIL .)


state 62

    (72) value -> DICT .

    YR              reduce using rule 72 (value -> DICT .)
    NEWLINE         reduce using rule 72 (value -> DICT .)
    COMMA           reduce using rule 72 (value -> DICT .)
    AN              reduce using rule 72 (value -> DICT .)
    MKAY            reduce using rule 72 (value -> DICT .)
    I               reduce using rule 72 (value -> DICT .)
    SIZE            reduce using rule 72 (value -> DICT .)
    ABSLUT          reduce using rule 72 (value -> DICT .)
    BINRY           reduce using rule 72 (value -> DICT .)
    SUM             reduce using rule 72 (value -> DICT .)
    DIFF            reduce using rule 72 (value -> DICT .)
    PRODUKT         reduce using rule 72 (value -> DICT .)
    QUOSHUNT        reduce using rule 72 (value -> DICT .)
    MOD             reduce using rule 72 (value -> DICT .)
    BIGGR           reduce using rule 72 (value -> DICT .)
    SMALLR          reduce using rule 72 (value -> DICT .)
    BOTH            reduce using rule 72 (value -> DICT .)
    EITHER          reduce using rule 72 (value -> DICT .)
    WON             reduce using rule 72 (value -> DICT .)
    NOT             reduce using rule 72 (value -> DICT .)
    ALL             reduce using rule 72 (value -> DICT .)
    ANY             reduce using rule 72 (value -> DICT .)
    DIFFRINT        reduce using rule 72 (value -> DICT .)
    SMOOSH          reduce using rule 72 (value -> DICT .)
    MAEK            reduce using rule 72 (value -> DICT .)
    ID              reduce using rule 72 (value -> DICT .)
    IT              reduce using rule 72 (value -> DICT .)
    STRING          reduce using rule 72 (value -> DICT .)
    FLOAT           reduce using rule 72 (value -> DICT .)
    INTEGER         reduce using rule 72 (value -> DICT .)
    WIN             reduce using rule 72 (value -> DICT .)
    FAIL            reduce using rule 72 (value -> DICT .)
    DICT            reduce using rule 72 (value -> DICT .)
    A               reduce using rule 72 (value -> DICT .)
    YARN            reduce using rule 72 (value -> DICT .)
    NUMBR           reduce using rule 72 (value -> DICT .)
    NUMBAR          reduce using rule 72 (value -> DICT .)
    NOOB            reduce using rule 72 (value -> DICT .)
    BUKKIT          reduce using rule 72 (value -> DICT .)
    EXCLAMATION     reduce using rule 72 (value -> DICT .)


state 63

    (1) program -> HAI FLOAT NEWLINE statements KTHXBYE .

    $end            reduce using rule 1 (program -> HAI FLOAT NEWLINE statements KTHXBYE .)


state 64

    (2) statements -> statements statement .

    KTHXBYE         reduce using rule 2 (statements -> statements statement .)
    I               reduce using rule 2 (statements -> statements statement .)
    SIZE            reduce using rule 2 (statements -> statements statement .)
    ABSLUT          reduce using rule 2 (statements -> statements statement .)
    BINRY           reduce using rule 2 (statements -> statements statement .)
    SUM             reduce using rule 2 (statements -> statements statement .)
    DIFF            reduce using rule 2 (statements -> statements statement .)
    PRODUKT         reduce using rule 2 (statements -> statements statement .)
    QUOSHUNT        reduce using rule 2 (statements -> statements statement .)
    MOD             reduce using rule 2 (statements -> statements statement .)
    BIGGR           reduce using rule 2 (statements -> statements statement .)
    SMALLR          reduce using rule 2 (statements -> statements statement .)
    BOTH            reduce using rule 2 (statements -> statements statement .)
    EITHER          reduce using rule 2 (statements -> statements statement .)
    WON             reduce using rule 2 (statements -> statements statement .)
    NOT             reduce using rule 2 (statements -> statements statement .)
    ALL             reduce using rule 2 (statements -> statements statement .)
    ANY             reduce using rule 2 (statements -> statements statement .)
    DIFFRINT        reduce using rule 2 (statements -> statements statement .)
    SMOOSH          reduce using rule 2 (statements -> statements statement .)
    MAEK            reduce using rule 2 (statements -> statements statement .)
    VISIBLE         reduce using rule 2 (statements -> statements statement .)
    GIMMEH          reduce using rule 2 (statements -> statements statement .)
    O               reduce using rule 2 (statements -> statements statement .)
    HOW             reduce using rule 2 (statements -> statements statement .)
    FOUND           reduce using rule 2 (statements -> statements statement .)
    GTFO            reduce using rule 2 (statements -> statements statement .)
    IM              reduce using rule 2 (statements -> statements statement .)
    YOU             reduce using rule 2 (statements -> statements statement .)
    CAN             reduce using rule 2 (statements -> statements statement .)
    ID              reduce using rule 2 (statements -> statements statement .)
    IT              reduce using rule 2 (statements -> statements statement .)
    STRING          reduce using rule 2 (statements -> statements statement .)
    FLOAT           reduce using rule 2 (statements -> statements statement .)
    INTEGER         reduce using rule 2 (statements -> statements statement .)
    WIN             reduce using rule 2 (statements -> statements statement .)
    FAIL            reduce using rule 2 (statements -> statements statement .)
    DICT            reduce using rule 2 (statements -> statements statement .)
    NEWLINE         reduce using rule 2 (statements -> statements statement .)
    COMMA           reduce using rule 2 (statements -> statements statement .)
    KTHX            reduce using rule 2 (statements -> statements statement .)
    IF              reduce using rule 2 (statements -> statements statement .)
    NO              reduce using rule 2 (statements -> statements statement .)
    OIC             reduce using rule 2 (statements -> statements statement .)
    MEBBE           reduce using rule 2 (statements -> statements statement .)


state 65

    (4) statement -> command NEWLINE .

    KTHXBYE         reduce using rule 4 (statement -> command NEWLINE .)
    I               reduce using rule 4 (statement -> command NEWLINE .)
    SIZE            reduce using rule 4 (statement -> command NEWLINE .)
    ABSLUT          reduce using rule 4 (statement -> command NEWLINE .)
    BINRY           reduce using rule 4 (statement -> command NEWLINE .)
    SUM             reduce using rule 4 (statement -> command NEWLINE .)
    DIFF            reduce using rule 4 (statement -> command NEWLINE .)
    PRODUKT         reduce using rule 4 (statement -> command NEWLINE .)
    QUOSHUNT        reduce using rule 4 (statement -> command NEWLINE .)
    MOD             reduce using rule 4 (statement -> command NEWLINE .)
    BIGGR           reduce using rule 4 (statement -> command NEWLINE .)
    SMALLR          reduce using rule 4 (statement -> command NEWLINE .)
    BOTH            reduce using rule 4 (statement -> command NEWLINE .)
    EITHER          reduce using rule 4 (statement -> command NEWLINE .)
    WON             reduce using rule 4 (statement -> command NEWLINE .)
    NOT             reduce using rule 4 (statement -> command NEWLINE .)
    ALL             reduce using rule 4 (statement -> command NEWLINE .)
    ANY             reduce using rule 4 (statement -> command NEWLINE .)
    DIFFRINT        reduce using rule 4 (statement -> command NEWLINE .)
    SMOOSH          reduce using rule 4 (statement -> command NEWLINE .)
    MAEK            reduce using rule 4 (statement -> command NEWLINE .)
    VISIBLE         reduce using rule 4 (statement -> command NEWLINE .)
    GIMMEH          reduce using rule 4 (statement -> command NEWLINE .)
    O               reduce using rule 4 (statement -> command NEWLINE .)
    HOW             reduce using rule 4 (statement -> command NEWLINE .)
    FOUND           reduce using rule 4 (statement -> command NEWLINE .)
    GTFO            reduce using rule 4 (statement -> command NEWLINE .)
    IM              reduce using rule 4 (statement -> command NEWLINE .)
    YOU             reduce using rule 4 (statement -> command NEWLINE .)
    CAN             reduce using rule 4 (statement -> command NEWLINE .)
    ID              reduce using rule 4 (statement -> command NEWLINE .)
    IT              reduce using rule 4 (statement -> command NEWLINE .)
    STRING          reduce using rule 4 (statement -> command NEWLINE .)
    FLOAT           reduce using rule 4 (statement -> command NEWLINE .)
    INTEGER         reduce using rule 4 (statement -> command NEWLINE .)
    WIN             reduce using rule 4 (statement -> command NEWLINE .)
    FAIL            reduce using rule 4 (statement -> command NEWLINE .)
    DICT            reduce using rule 4 (statement -> command NEWLINE .)
    NEWLINE         reduce using rule 4 (statement -> command NEWLINE .)
    COMMA           reduce using rule 4 (statement -> command NEWLINE .)
    KTHX            reduce using rule 4 (statement -> command NEWLINE .)
    IF              reduce using rule 4 (statement -> command NEWLINE .)
    NO              reduce using rule 4 (statement -> command NEWLINE .)
    OIC             reduce using rule 4 (statement -> command NEWLINE .)
    MEBBE           reduce using rule 4 (statement -> command NEWLINE .)


state 66

    (5) statement -> command COMMA .

    KTHXBYE         reduce using rule 5 (statement -> command COMMA .)
    I               reduce using rule 5 (statement -> command COMMA .)
    SIZE            reduce using rule 5 (statement -> command COMMA .)
    ABSLUT          reduce using rule 5 (statement -> command COMMA .)
    BINRY           reduce using rule 5 (statement -> command COMMA .)
    SUM             reduce using rule 5 (statement -> command COMMA .)
    DIFF            reduce using rule 5 (statement -> command COMMA .)
    PRODUKT         reduce using rule 5 (statement -> command COMMA .)
    QUOSHUNT        reduce using rule 5 (statement -> command COMMA .)
    MOD             reduce using rule 5 (statement -> command COMMA .)
    BIGGR           reduce using rule 5 (statement -> command COMMA .)
    SMALLR          reduce using rule 5 (statement -> command COMMA .)
    BOTH            reduce using rule 5 (statement -> command COMMA .)
    EITHER          reduce using rule 5 (statement -> command COMMA .)
    WON             reduce using rule 5 (statement -> command COMMA .)
    NOT             reduce using rule 5 (statement -> command COMMA .)
    ALL             reduce using rule 5 (statement -> command COMMA .)
    ANY             reduce using rule 5 (statement -> command COMMA .)
    DIFFRINT        reduce using rule 5 (statement -> command COMMA .)
    SMOOSH          reduce using rule 5 (statement -> command COMMA .)
    MAEK            reduce using rule 5 (statement -> command COMMA .)
    VISIBLE         reduce using rule 5 (statement -> command COMMA .)
    GIMMEH          reduce using rule 5 (statement -> command COMMA .)
    O               reduce using rule 5 (statement -> command COMMA .)
    HOW             reduce using rule 5 (statement -> command COMMA .)
    FOUND           reduce using rule 5 (statement -> command COMMA .)
    GTFO            reduce using rule 5 (statement -> command COMMA .)
    IM              reduce using rule 5 (statement -> command COMMA .)
    YOU             reduce using rule 5 (statement -> command COMMA .)
    CAN             reduce using rule 5 (statement -> command COMMA .)
    ID              reduce using rule 5 (statement -> command COMMA .)
    IT              reduce using rule 5 (statement -> command COMMA .)
    STRING          reduce using rule 5 (statement -> command COMMA .)
    FLOAT           reduce using rule 5 (statement -> command COMMA .)
    INTEGER         reduce using rule 5 (statement -> command COMMA .)
    WIN             reduce using rule 5 (statement -> command COMMA .)
    FAIL            reduce using rule 5 (statement -> command COMMA .)
    DICT            reduce using rule 5 (statement -> command COMMA .)
    NEWLINE         reduce using rule 5 (statement -> command COMMA .)
    COMMA           reduce using rule 5 (statement -> command COMMA .)
    KTHX            reduce using rule 5 (statement -> command COMMA .)
    IF              reduce using rule 5 (statement -> command COMMA .)
    NO              reduce using rule 5 (statement -> command COMMA .)
    OIC             reduce using rule 5 (statement -> command COMMA .)
    MEBBE           reduce using rule 5 (statement -> command COMMA .)


state 67

    (79) expr -> expr YR . BASE ARE BELONG TO expr

    BASE            shift and go to state 109


state 68

    (42) expr -> variable APOSTROPHE_Z . variable
    (103) variable -> . ID
    (104) variable -> . IT

    ID              shift and go to state 27
    IT              shift and go to state 57

    variable                       shift and go to state 110

state 69

    (58) expr -> variable IZ . ID YR sep_yr_args MKAY
    (59) expr -> variable IZ . ID

    ID              shift and go to state 111


state 70

    (43) cast -> variable IS . NOW A type

    NOW             shift and go to state 112


state 71

    (44) cast -> variable R . MAEK variable A type
    (45) cast -> variable R . MAEK variable type
    (41) assign -> variable R . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    MAEK            shift and go to state 113
    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 90
    expr                           shift and go to state 114
    value                          shift and go to state 31

state 72

    (40) assign_bukkit -> variable HAS . A variable ITZ expr

    A               shift and go to state 115


state 73

    (56) expr -> I IZ . ID YR sep_yr_args MKAY
    (57) expr -> I IZ . ID

    ID              shift and go to state 116


state 74

    (35) decl -> I HAS . A variable
    (36) decl -> I HAS . A variable ITZ expr
    (37) decl -> I HAS . A variable ITZ A type
    (38) decl -> I HAS . A variable ITZ LIEK A variable

    A               shift and go to state 117


state 75

    (76) expr -> SIZE OF . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 118
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 76

    (77) expr -> ABSLUT OF . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 119
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 77

    (78) expr -> BINRY OF . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 120
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 78

    (82) expr -> SUM OF . expr AN expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 121
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 79

    (83) expr -> DIFF OF . expr AN expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 122
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 80

    (84) expr -> PRODUKT OF . expr AN expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 123
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 81

    (85) expr -> QUOSHUNT OF . expr AN expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 124
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 82

    (86) expr -> MOD OF . expr AN expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 125
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 83

    (87) expr -> BIGGR OF . expr AN expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 126
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 84

    (88) expr -> SMALLR OF . expr AN expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 127
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 85

    (89) expr -> BOTH OF . expr AN expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 128
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 86

    (97) expr -> BOTH SAEM . expr AN expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 129
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 87

    (90) expr -> EITHER OF . expr AN expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 130
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 88

    (91) expr -> WON OF . expr AN expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 131
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 89

    (92) expr -> NOT expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 92 (expr -> NOT expr .)
    COMMA           reduce using rule 92 (expr -> NOT expr .)
    AN              reduce using rule 92 (expr -> NOT expr .)
    MKAY            reduce using rule 92 (expr -> NOT expr .)
    I               reduce using rule 92 (expr -> NOT expr .)
    SIZE            reduce using rule 92 (expr -> NOT expr .)
    ABSLUT          reduce using rule 92 (expr -> NOT expr .)
    BINRY           reduce using rule 92 (expr -> NOT expr .)
    SUM             reduce using rule 92 (expr -> NOT expr .)
    DIFF            reduce using rule 92 (expr -> NOT expr .)
    PRODUKT         reduce using rule 92 (expr -> NOT expr .)
    QUOSHUNT        reduce using rule 92 (expr -> NOT expr .)
    MOD             reduce using rule 92 (expr -> NOT expr .)
    BIGGR           reduce using rule 92 (expr -> NOT expr .)
    SMALLR          reduce using rule 92 (expr -> NOT expr .)
    BOTH            reduce using rule 92 (expr -> NOT expr .)
    EITHER          reduce using rule 92 (expr -> NOT expr .)
    WON             reduce using rule 92 (expr -> NOT expr .)
    NOT             reduce using rule 92 (expr -> NOT expr .)
    ALL             reduce using rule 92 (expr -> NOT expr .)
    ANY             reduce using rule 92 (expr -> NOT expr .)
    DIFFRINT        reduce using rule 92 (expr -> NOT expr .)
    SMOOSH          reduce using rule 92 (expr -> NOT expr .)
    MAEK            reduce using rule 92 (expr -> NOT expr .)
    ID              reduce using rule 92 (expr -> NOT expr .)
    IT              reduce using rule 92 (expr -> NOT expr .)
    STRING          reduce using rule 92 (expr -> NOT expr .)
    FLOAT           reduce using rule 92 (expr -> NOT expr .)
    INTEGER         reduce using rule 92 (expr -> NOT expr .)
    WIN             reduce using rule 92 (expr -> NOT expr .)
    FAIL            reduce using rule 92 (expr -> NOT expr .)
    DICT            reduce using rule 92 (expr -> NOT expr .)
    A               reduce using rule 92 (expr -> NOT expr .)
    YARN            reduce using rule 92 (expr -> NOT expr .)
    NUMBR           reduce using rule 92 (expr -> NOT expr .)
    NUMBAR          reduce using rule 92 (expr -> NOT expr .)
    NOOB            reduce using rule 92 (expr -> NOT expr .)
    BUKKIT          reduce using rule 92 (expr -> NOT expr .)
    EXCLAMATION     reduce using rule 92 (expr -> NOT expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 92 (expr -> NOT expr .) ]


state 90

    (42) expr -> variable . APOSTROPHE_Z variable
    (58) expr -> variable . IZ ID YR sep_yr_args MKAY
    (59) expr -> variable . IZ ID
    (81) expr -> variable .

    APOSTROPHE_Z    shift and go to state 68
    IZ              shift and go to state 69
    YR              reduce using rule 81 (expr -> variable .)
    NEWLINE         reduce using rule 81 (expr -> variable .)
    COMMA           reduce using rule 81 (expr -> variable .)
    AN              reduce using rule 81 (expr -> variable .)
    MKAY            reduce using rule 81 (expr -> variable .)
    I               reduce using rule 81 (expr -> variable .)
    SIZE            reduce using rule 81 (expr -> variable .)
    ABSLUT          reduce using rule 81 (expr -> variable .)
    BINRY           reduce using rule 81 (expr -> variable .)
    SUM             reduce using rule 81 (expr -> variable .)
    DIFF            reduce using rule 81 (expr -> variable .)
    PRODUKT         reduce using rule 81 (expr -> variable .)
    QUOSHUNT        reduce using rule 81 (expr -> variable .)
    MOD             reduce using rule 81 (expr -> variable .)
    BIGGR           reduce using rule 81 (expr -> variable .)
    SMALLR          reduce using rule 81 (expr -> variable .)
    BOTH            reduce using rule 81 (expr -> variable .)
    EITHER          reduce using rule 81 (expr -> variable .)
    WON             reduce using rule 81 (expr -> variable .)
    NOT             reduce using rule 81 (expr -> variable .)
    ALL             reduce using rule 81 (expr -> variable .)
    ANY             reduce using rule 81 (expr -> variable .)
    DIFFRINT        reduce using rule 81 (expr -> variable .)
    SMOOSH          reduce using rule 81 (expr -> variable .)
    MAEK            reduce using rule 81 (expr -> variable .)
    ID              reduce using rule 81 (expr -> variable .)
    IT              reduce using rule 81 (expr -> variable .)
    STRING          reduce using rule 81 (expr -> variable .)
    FLOAT           reduce using rule 81 (expr -> variable .)
    INTEGER         reduce using rule 81 (expr -> variable .)
    WIN             reduce using rule 81 (expr -> variable .)
    FAIL            reduce using rule 81 (expr -> variable .)
    DICT            reduce using rule 81 (expr -> variable .)
    A               reduce using rule 81 (expr -> variable .)
    YARN            reduce using rule 81 (expr -> variable .)
    NUMBR           reduce using rule 81 (expr -> variable .)
    NUMBAR          reduce using rule 81 (expr -> variable .)
    NOOB            reduce using rule 81 (expr -> variable .)
    BUKKIT          reduce using rule 81 (expr -> variable .)
    EXCLAMATION     reduce using rule 81 (expr -> variable .)


state 91

    (56) expr -> I . IZ ID YR sep_yr_args MKAY
    (57) expr -> I . IZ ID

    IZ              shift and go to state 73


state 92

    (93) expr -> ALL OF . sep_args MKAY
    (95) expr -> ALL OF . args MKAY
    (48) sep_args -> . sep_args AN expr
    (49) sep_args -> . expr
    (46) args -> . args expr
    (47) args -> . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    sep_args                       shift and go to state 132
    args                           shift and go to state 133
    expr                           shift and go to state 97
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 93

    (94) expr -> ANY OF . sep_args MKAY
    (96) expr -> ANY OF . args MKAY
    (48) sep_args -> . sep_args AN expr
    (49) sep_args -> . expr
    (46) args -> . args expr
    (47) args -> . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    sep_args                       shift and go to state 134
    args                           shift and go to state 135
    expr                           shift and go to state 97
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 94

    (98) expr -> DIFFRINT expr . AN expr
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    AN              shift and go to state 136
    YR              shift and go to state 67


state 95

    (99) expr -> SMOOSH sep_args . MKAY
    (48) sep_args -> sep_args . AN expr

    MKAY            shift and go to state 137
    AN              shift and go to state 138


state 96

    (100) expr -> SMOOSH args . MKAY
    (46) args -> args . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    MKAY            shift and go to state 139
    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 140
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 97

    (49) sep_args -> expr .
    (47) args -> expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! reduce/reduce conflict for MKAY resolved using rule 47 (args -> expr .)
    AN              reduce using rule 49 (sep_args -> expr .)
    MKAY            reduce using rule 47 (args -> expr .)
    I               reduce using rule 47 (args -> expr .)
    SIZE            reduce using rule 47 (args -> expr .)
    ABSLUT          reduce using rule 47 (args -> expr .)
    BINRY           reduce using rule 47 (args -> expr .)
    SUM             reduce using rule 47 (args -> expr .)
    DIFF            reduce using rule 47 (args -> expr .)
    PRODUKT         reduce using rule 47 (args -> expr .)
    QUOSHUNT        reduce using rule 47 (args -> expr .)
    MOD             reduce using rule 47 (args -> expr .)
    BIGGR           reduce using rule 47 (args -> expr .)
    SMALLR          reduce using rule 47 (args -> expr .)
    BOTH            reduce using rule 47 (args -> expr .)
    EITHER          reduce using rule 47 (args -> expr .)
    WON             reduce using rule 47 (args -> expr .)
    NOT             reduce using rule 47 (args -> expr .)
    ALL             reduce using rule 47 (args -> expr .)
    ANY             reduce using rule 47 (args -> expr .)
    DIFFRINT        reduce using rule 47 (args -> expr .)
    SMOOSH          reduce using rule 47 (args -> expr .)
    MAEK            reduce using rule 47 (args -> expr .)
    ID              reduce using rule 47 (args -> expr .)
    IT              reduce using rule 47 (args -> expr .)
    STRING          reduce using rule 47 (args -> expr .)
    FLOAT           reduce using rule 47 (args -> expr .)
    INTEGER         reduce using rule 47 (args -> expr .)
    WIN             reduce using rule 47 (args -> expr .)
    FAIL            reduce using rule 47 (args -> expr .)
    DICT            reduce using rule 47 (args -> expr .)
    YR              shift and go to state 67

  ! MKAY            [ reduce using rule 49 (sep_args -> expr .) ]


state 98

    (101) expr -> MAEK expr . A type
    (102) expr -> MAEK expr . type
    (79) expr -> expr . YR BASE ARE BELONG TO expr
    (62) type -> . YARN
    (63) type -> . NUMBR
    (64) type -> . NUMBAR
    (65) type -> . NOOB
    (66) type -> . BUKKIT

    A               shift and go to state 141
    YR              shift and go to state 67
    YARN            shift and go to state 143
    NUMBR           shift and go to state 144
    NUMBAR          shift and go to state 145
    NOOB            shift and go to state 146
    BUKKIT          shift and go to state 147

    type                           shift and go to state 142

state 99

    (73) call -> VISIBLE args .
    (74) call -> VISIBLE args . EXCLAMATION
    (46) args -> args . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NEWLINE         reduce using rule 73 (call -> VISIBLE args .)
    COMMA           reduce using rule 73 (call -> VISIBLE args .)
    EXCLAMATION     shift and go to state 148
    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 140
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 100

    (47) args -> expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    EXCLAMATION     reduce using rule 47 (args -> expr .)
    I               reduce using rule 47 (args -> expr .)
    SIZE            reduce using rule 47 (args -> expr .)
    ABSLUT          reduce using rule 47 (args -> expr .)
    BINRY           reduce using rule 47 (args -> expr .)
    SUM             reduce using rule 47 (args -> expr .)
    DIFF            reduce using rule 47 (args -> expr .)
    PRODUKT         reduce using rule 47 (args -> expr .)
    QUOSHUNT        reduce using rule 47 (args -> expr .)
    MOD             reduce using rule 47 (args -> expr .)
    BIGGR           reduce using rule 47 (args -> expr .)
    SMALLR          reduce using rule 47 (args -> expr .)
    BOTH            reduce using rule 47 (args -> expr .)
    EITHER          reduce using rule 47 (args -> expr .)
    WON             reduce using rule 47 (args -> expr .)
    NOT             reduce using rule 47 (args -> expr .)
    ALL             reduce using rule 47 (args -> expr .)
    ANY             reduce using rule 47 (args -> expr .)
    DIFFRINT        reduce using rule 47 (args -> expr .)
    SMOOSH          reduce using rule 47 (args -> expr .)
    MAEK            reduce using rule 47 (args -> expr .)
    ID              reduce using rule 47 (args -> expr .)
    IT              reduce using rule 47 (args -> expr .)
    STRING          reduce using rule 47 (args -> expr .)
    FLOAT           reduce using rule 47 (args -> expr .)
    INTEGER         reduce using rule 47 (args -> expr .)
    WIN             reduce using rule 47 (args -> expr .)
    FAIL            reduce using rule 47 (args -> expr .)
    DICT            reduce using rule 47 (args -> expr .)
    NEWLINE         reduce using rule 47 (args -> expr .)
    COMMA           reduce using rule 47 (args -> expr .)
    YR              shift and go to state 67


state 101

    (75) call -> GIMMEH variable .

    NEWLINE         reduce using rule 75 (call -> GIMMEH variable .)
    COMMA           reduce using rule 75 (call -> GIMMEH variable .)


state 102

    (39) declare_bukkit_block -> O HAI . IM variable NEWLINE statements KTHX

    IM              shift and go to state 149


state 103

    (29) if_else -> O RLY . QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> O RLY . QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> O RLY . QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC

    QUESTION        shift and go to state 150


state 104

    (21) loop -> IM IN . YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable

    YR              shift and go to state 151


state 105

    (52) bukkit_function -> HOW IZ . variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> HOW IZ . variable ID NEWLINE statements IF U SAY SO
    (54) function -> HOW IZ . I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> HOW IZ . I ID NEWLINE statements IF U SAY SO
    (103) variable -> . ID
    (104) variable -> . IT

    I               shift and go to state 153
    ID              shift and go to state 27
    IT              shift and go to state 57

    variable                       shift and go to state 152

state 106

    (60) return -> FOUND YR . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 154
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 107

    (28) export -> YOU CAN . HAS sep_args MKAY

    HAS             shift and go to state 155


state 108

    (26) import -> CAN HAS . PATH QUESTION
    (27) import -> CAN HAS . SNEK PATH QUESTION

    PATH            shift and go to state 156
    SNEK            shift and go to state 157


state 109

    (79) expr -> expr YR BASE . ARE BELONG TO expr

    ARE             shift and go to state 158


state 110

    (42) expr -> variable APOSTROPHE_Z variable .

    YR              reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    NEWLINE         reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    COMMA           reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    AN              reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    MKAY            reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    I               reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    SIZE            reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    ABSLUT          reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    BINRY           reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    SUM             reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    DIFF            reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    PRODUKT         reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    QUOSHUNT        reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    MOD             reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    BIGGR           reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    SMALLR          reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    BOTH            reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    EITHER          reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    WON             reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    NOT             reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    ALL             reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    ANY             reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    DIFFRINT        reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    SMOOSH          reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    MAEK            reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    ID              reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    IT              reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    STRING          reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    FLOAT           reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    INTEGER         reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    WIN             reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    FAIL            reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    DICT            reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    A               reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    YARN            reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    NUMBR           reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    NUMBAR          reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    NOOB            reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    BUKKIT          reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)
    EXCLAMATION     reduce using rule 42 (expr -> variable APOSTROPHE_Z variable .)


state 111

    (58) expr -> variable IZ ID . YR sep_yr_args MKAY
    (59) expr -> variable IZ ID .

  ! shift/reduce conflict for YR resolved as shift
    YR              shift and go to state 159
    NEWLINE         reduce using rule 59 (expr -> variable IZ ID .)
    COMMA           reduce using rule 59 (expr -> variable IZ ID .)
    AN              reduce using rule 59 (expr -> variable IZ ID .)
    MKAY            reduce using rule 59 (expr -> variable IZ ID .)
    I               reduce using rule 59 (expr -> variable IZ ID .)
    SIZE            reduce using rule 59 (expr -> variable IZ ID .)
    ABSLUT          reduce using rule 59 (expr -> variable IZ ID .)
    BINRY           reduce using rule 59 (expr -> variable IZ ID .)
    SUM             reduce using rule 59 (expr -> variable IZ ID .)
    DIFF            reduce using rule 59 (expr -> variable IZ ID .)
    PRODUKT         reduce using rule 59 (expr -> variable IZ ID .)
    QUOSHUNT        reduce using rule 59 (expr -> variable IZ ID .)
    MOD             reduce using rule 59 (expr -> variable IZ ID .)
    BIGGR           reduce using rule 59 (expr -> variable IZ ID .)
    SMALLR          reduce using rule 59 (expr -> variable IZ ID .)
    BOTH            reduce using rule 59 (expr -> variable IZ ID .)
    EITHER          reduce using rule 59 (expr -> variable IZ ID .)
    WON             reduce using rule 59 (expr -> variable IZ ID .)
    NOT             reduce using rule 59 (expr -> variable IZ ID .)
    ALL             reduce using rule 59 (expr -> variable IZ ID .)
    ANY             reduce using rule 59 (expr -> variable IZ ID .)
    DIFFRINT        reduce using rule 59 (expr -> variable IZ ID .)
    SMOOSH          reduce using rule 59 (expr -> variable IZ ID .)
    MAEK            reduce using rule 59 (expr -> variable IZ ID .)
    ID              reduce using rule 59 (expr -> variable IZ ID .)
    IT              reduce using rule 59 (expr -> variable IZ ID .)
    STRING          reduce using rule 59 (expr -> variable IZ ID .)
    FLOAT           reduce using rule 59 (expr -> variable IZ ID .)
    INTEGER         reduce using rule 59 (expr -> variable IZ ID .)
    WIN             reduce using rule 59 (expr -> variable IZ ID .)
    FAIL            reduce using rule 59 (expr -> variable IZ ID .)
    DICT            reduce using rule 59 (expr -> variable IZ ID .)
    A               reduce using rule 59 (expr -> variable IZ ID .)
    YARN            reduce using rule 59 (expr -> variable IZ ID .)
    NUMBR           reduce using rule 59 (expr -> variable IZ ID .)
    NUMBAR          reduce using rule 59 (expr -> variable IZ ID .)
    NOOB            reduce using rule 59 (expr -> variable IZ ID .)
    BUKKIT          reduce using rule 59 (expr -> variable IZ ID .)
    EXCLAMATION     reduce using rule 59 (expr -> variable IZ ID .)

  ! YR              [ reduce using rule 59 (expr -> variable IZ ID .) ]


state 112

    (43) cast -> variable IS NOW . A type

    A               shift and go to state 160


state 113

    (44) cast -> variable R MAEK . variable A type
    (45) cast -> variable R MAEK . variable type
    (101) expr -> MAEK . expr A type
    (102) expr -> MAEK . expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    ID              shift and go to state 27
    IT              shift and go to state 57
    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 161
    expr                           shift and go to state 98
    value                          shift and go to state 31

state 114

    (41) assign -> variable R expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    NEWLINE         reduce using rule 41 (assign -> variable R expr .)
    COMMA           reduce using rule 41 (assign -> variable R expr .)
    YR              shift and go to state 67


state 115

    (40) assign_bukkit -> variable HAS A . variable ITZ expr
    (103) variable -> . ID
    (104) variable -> . IT

    ID              shift and go to state 27
    IT              shift and go to state 57

    variable                       shift and go to state 162

state 116

    (56) expr -> I IZ ID . YR sep_yr_args MKAY
    (57) expr -> I IZ ID .

  ! shift/reduce conflict for YR resolved as shift
    YR              shift and go to state 163
    NEWLINE         reduce using rule 57 (expr -> I IZ ID .)
    COMMA           reduce using rule 57 (expr -> I IZ ID .)
    AN              reduce using rule 57 (expr -> I IZ ID .)
    MKAY            reduce using rule 57 (expr -> I IZ ID .)
    I               reduce using rule 57 (expr -> I IZ ID .)
    SIZE            reduce using rule 57 (expr -> I IZ ID .)
    ABSLUT          reduce using rule 57 (expr -> I IZ ID .)
    BINRY           reduce using rule 57 (expr -> I IZ ID .)
    SUM             reduce using rule 57 (expr -> I IZ ID .)
    DIFF            reduce using rule 57 (expr -> I IZ ID .)
    PRODUKT         reduce using rule 57 (expr -> I IZ ID .)
    QUOSHUNT        reduce using rule 57 (expr -> I IZ ID .)
    MOD             reduce using rule 57 (expr -> I IZ ID .)
    BIGGR           reduce using rule 57 (expr -> I IZ ID .)
    SMALLR          reduce using rule 57 (expr -> I IZ ID .)
    BOTH            reduce using rule 57 (expr -> I IZ ID .)
    EITHER          reduce using rule 57 (expr -> I IZ ID .)
    WON             reduce using rule 57 (expr -> I IZ ID .)
    NOT             reduce using rule 57 (expr -> I IZ ID .)
    ALL             reduce using rule 57 (expr -> I IZ ID .)
    ANY             reduce using rule 57 (expr -> I IZ ID .)
    DIFFRINT        reduce using rule 57 (expr -> I IZ ID .)
    SMOOSH          reduce using rule 57 (expr -> I IZ ID .)
    MAEK            reduce using rule 57 (expr -> I IZ ID .)
    ID              reduce using rule 57 (expr -> I IZ ID .)
    IT              reduce using rule 57 (expr -> I IZ ID .)
    STRING          reduce using rule 57 (expr -> I IZ ID .)
    FLOAT           reduce using rule 57 (expr -> I IZ ID .)
    INTEGER         reduce using rule 57 (expr -> I IZ ID .)
    WIN             reduce using rule 57 (expr -> I IZ ID .)
    FAIL            reduce using rule 57 (expr -> I IZ ID .)
    DICT            reduce using rule 57 (expr -> I IZ ID .)
    A               reduce using rule 57 (expr -> I IZ ID .)
    YARN            reduce using rule 57 (expr -> I IZ ID .)
    NUMBR           reduce using rule 57 (expr -> I IZ ID .)
    NUMBAR          reduce using rule 57 (expr -> I IZ ID .)
    NOOB            reduce using rule 57 (expr -> I IZ ID .)
    BUKKIT          reduce using rule 57 (expr -> I IZ ID .)
    EXCLAMATION     reduce using rule 57 (expr -> I IZ ID .)

  ! YR              [ reduce using rule 57 (expr -> I IZ ID .) ]


state 117

    (35) decl -> I HAS A . variable
    (36) decl -> I HAS A . variable ITZ expr
    (37) decl -> I HAS A . variable ITZ A type
    (38) decl -> I HAS A . variable ITZ LIEK A variable
    (103) variable -> . ID
    (104) variable -> . IT

    ID              shift and go to state 27
    IT              shift and go to state 57

    variable                       shift and go to state 164

state 118

    (76) expr -> SIZE OF expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 76 (expr -> SIZE OF expr .)
    COMMA           reduce using rule 76 (expr -> SIZE OF expr .)
    AN              reduce using rule 76 (expr -> SIZE OF expr .)
    MKAY            reduce using rule 76 (expr -> SIZE OF expr .)
    I               reduce using rule 76 (expr -> SIZE OF expr .)
    SIZE            reduce using rule 76 (expr -> SIZE OF expr .)
    ABSLUT          reduce using rule 76 (expr -> SIZE OF expr .)
    BINRY           reduce using rule 76 (expr -> SIZE OF expr .)
    SUM             reduce using rule 76 (expr -> SIZE OF expr .)
    DIFF            reduce using rule 76 (expr -> SIZE OF expr .)
    PRODUKT         reduce using rule 76 (expr -> SIZE OF expr .)
    QUOSHUNT        reduce using rule 76 (expr -> SIZE OF expr .)
    MOD             reduce using rule 76 (expr -> SIZE OF expr .)
    BIGGR           reduce using rule 76 (expr -> SIZE OF expr .)
    SMALLR          reduce using rule 76 (expr -> SIZE OF expr .)
    BOTH            reduce using rule 76 (expr -> SIZE OF expr .)
    EITHER          reduce using rule 76 (expr -> SIZE OF expr .)
    WON             reduce using rule 76 (expr -> SIZE OF expr .)
    NOT             reduce using rule 76 (expr -> SIZE OF expr .)
    ALL             reduce using rule 76 (expr -> SIZE OF expr .)
    ANY             reduce using rule 76 (expr -> SIZE OF expr .)
    DIFFRINT        reduce using rule 76 (expr -> SIZE OF expr .)
    SMOOSH          reduce using rule 76 (expr -> SIZE OF expr .)
    MAEK            reduce using rule 76 (expr -> SIZE OF expr .)
    ID              reduce using rule 76 (expr -> SIZE OF expr .)
    IT              reduce using rule 76 (expr -> SIZE OF expr .)
    STRING          reduce using rule 76 (expr -> SIZE OF expr .)
    FLOAT           reduce using rule 76 (expr -> SIZE OF expr .)
    INTEGER         reduce using rule 76 (expr -> SIZE OF expr .)
    WIN             reduce using rule 76 (expr -> SIZE OF expr .)
    FAIL            reduce using rule 76 (expr -> SIZE OF expr .)
    DICT            reduce using rule 76 (expr -> SIZE OF expr .)
    A               reduce using rule 76 (expr -> SIZE OF expr .)
    YARN            reduce using rule 76 (expr -> SIZE OF expr .)
    NUMBR           reduce using rule 76 (expr -> SIZE OF expr .)
    NUMBAR          reduce using rule 76 (expr -> SIZE OF expr .)
    NOOB            reduce using rule 76 (expr -> SIZE OF expr .)
    BUKKIT          reduce using rule 76 (expr -> SIZE OF expr .)
    EXCLAMATION     reduce using rule 76 (expr -> SIZE OF expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 76 (expr -> SIZE OF expr .) ]


state 119

    (77) expr -> ABSLUT OF expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 77 (expr -> ABSLUT OF expr .)
    COMMA           reduce using rule 77 (expr -> ABSLUT OF expr .)
    AN              reduce using rule 77 (expr -> ABSLUT OF expr .)
    MKAY            reduce using rule 77 (expr -> ABSLUT OF expr .)
    I               reduce using rule 77 (expr -> ABSLUT OF expr .)
    SIZE            reduce using rule 77 (expr -> ABSLUT OF expr .)
    ABSLUT          reduce using rule 77 (expr -> ABSLUT OF expr .)
    BINRY           reduce using rule 77 (expr -> ABSLUT OF expr .)
    SUM             reduce using rule 77 (expr -> ABSLUT OF expr .)
    DIFF            reduce using rule 77 (expr -> ABSLUT OF expr .)
    PRODUKT         reduce using rule 77 (expr -> ABSLUT OF expr .)
    QUOSHUNT        reduce using rule 77 (expr -> ABSLUT OF expr .)
    MOD             reduce using rule 77 (expr -> ABSLUT OF expr .)
    BIGGR           reduce using rule 77 (expr -> ABSLUT OF expr .)
    SMALLR          reduce using rule 77 (expr -> ABSLUT OF expr .)
    BOTH            reduce using rule 77 (expr -> ABSLUT OF expr .)
    EITHER          reduce using rule 77 (expr -> ABSLUT OF expr .)
    WON             reduce using rule 77 (expr -> ABSLUT OF expr .)
    NOT             reduce using rule 77 (expr -> ABSLUT OF expr .)
    ALL             reduce using rule 77 (expr -> ABSLUT OF expr .)
    ANY             reduce using rule 77 (expr -> ABSLUT OF expr .)
    DIFFRINT        reduce using rule 77 (expr -> ABSLUT OF expr .)
    SMOOSH          reduce using rule 77 (expr -> ABSLUT OF expr .)
    MAEK            reduce using rule 77 (expr -> ABSLUT OF expr .)
    ID              reduce using rule 77 (expr -> ABSLUT OF expr .)
    IT              reduce using rule 77 (expr -> ABSLUT OF expr .)
    STRING          reduce using rule 77 (expr -> ABSLUT OF expr .)
    FLOAT           reduce using rule 77 (expr -> ABSLUT OF expr .)
    INTEGER         reduce using rule 77 (expr -> ABSLUT OF expr .)
    WIN             reduce using rule 77 (expr -> ABSLUT OF expr .)
    FAIL            reduce using rule 77 (expr -> ABSLUT OF expr .)
    DICT            reduce using rule 77 (expr -> ABSLUT OF expr .)
    A               reduce using rule 77 (expr -> ABSLUT OF expr .)
    YARN            reduce using rule 77 (expr -> ABSLUT OF expr .)
    NUMBR           reduce using rule 77 (expr -> ABSLUT OF expr .)
    NUMBAR          reduce using rule 77 (expr -> ABSLUT OF expr .)
    NOOB            reduce using rule 77 (expr -> ABSLUT OF expr .)
    BUKKIT          reduce using rule 77 (expr -> ABSLUT OF expr .)
    EXCLAMATION     reduce using rule 77 (expr -> ABSLUT OF expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 77 (expr -> ABSLUT OF expr .) ]


state 120

    (78) expr -> BINRY OF expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 78 (expr -> BINRY OF expr .)
    COMMA           reduce using rule 78 (expr -> BINRY OF expr .)
    AN              reduce using rule 78 (expr -> BINRY OF expr .)
    MKAY            reduce using rule 78 (expr -> BINRY OF expr .)
    I               reduce using rule 78 (expr -> BINRY OF expr .)
    SIZE            reduce using rule 78 (expr -> BINRY OF expr .)
    ABSLUT          reduce using rule 78 (expr -> BINRY OF expr .)
    BINRY           reduce using rule 78 (expr -> BINRY OF expr .)
    SUM             reduce using rule 78 (expr -> BINRY OF expr .)
    DIFF            reduce using rule 78 (expr -> BINRY OF expr .)
    PRODUKT         reduce using rule 78 (expr -> BINRY OF expr .)
    QUOSHUNT        reduce using rule 78 (expr -> BINRY OF expr .)
    MOD             reduce using rule 78 (expr -> BINRY OF expr .)
    BIGGR           reduce using rule 78 (expr -> BINRY OF expr .)
    SMALLR          reduce using rule 78 (expr -> BINRY OF expr .)
    BOTH            reduce using rule 78 (expr -> BINRY OF expr .)
    EITHER          reduce using rule 78 (expr -> BINRY OF expr .)
    WON             reduce using rule 78 (expr -> BINRY OF expr .)
    NOT             reduce using rule 78 (expr -> BINRY OF expr .)
    ALL             reduce using rule 78 (expr -> BINRY OF expr .)
    ANY             reduce using rule 78 (expr -> BINRY OF expr .)
    DIFFRINT        reduce using rule 78 (expr -> BINRY OF expr .)
    SMOOSH          reduce using rule 78 (expr -> BINRY OF expr .)
    MAEK            reduce using rule 78 (expr -> BINRY OF expr .)
    ID              reduce using rule 78 (expr -> BINRY OF expr .)
    IT              reduce using rule 78 (expr -> BINRY OF expr .)
    STRING          reduce using rule 78 (expr -> BINRY OF expr .)
    FLOAT           reduce using rule 78 (expr -> BINRY OF expr .)
    INTEGER         reduce using rule 78 (expr -> BINRY OF expr .)
    WIN             reduce using rule 78 (expr -> BINRY OF expr .)
    FAIL            reduce using rule 78 (expr -> BINRY OF expr .)
    DICT            reduce using rule 78 (expr -> BINRY OF expr .)
    A               reduce using rule 78 (expr -> BINRY OF expr .)
    YARN            reduce using rule 78 (expr -> BINRY OF expr .)
    NUMBR           reduce using rule 78 (expr -> BINRY OF expr .)
    NUMBAR          reduce using rule 78 (expr -> BINRY OF expr .)
    NOOB            reduce using rule 78 (expr -> BINRY OF expr .)
    BUKKIT          reduce using rule 78 (expr -> BINRY OF expr .)
    EXCLAMATION     reduce using rule 78 (expr -> BINRY OF expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 78 (expr -> BINRY OF expr .) ]


state 121

    (82) expr -> SUM OF expr . AN expr
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    AN              shift and go to state 165
    YR              shift and go to state 67


state 122

    (83) expr -> DIFF OF expr . AN expr
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    AN              shift and go to state 166
    YR              shift and go to state 67


state 123

    (84) expr -> PRODUKT OF expr . AN expr
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    AN              shift and go to state 167
    YR              shift and go to state 67


state 124

    (85) expr -> QUOSHUNT OF expr . AN expr
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    AN              shift and go to state 168
    YR              shift and go to state 67


state 125

    (86) expr -> MOD OF expr . AN expr
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    AN              shift and go to state 169
    YR              shift and go to state 67


state 126

    (87) expr -> BIGGR OF expr . AN expr
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    AN              shift and go to state 170
    YR              shift and go to state 67


state 127

    (88) expr -> SMALLR OF expr . AN expr
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    AN              shift and go to state 171
    YR              shift and go to state 67


state 128

    (89) expr -> BOTH OF expr . AN expr
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    AN              shift and go to state 172
    YR              shift and go to state 67


state 129

    (97) expr -> BOTH SAEM expr . AN expr
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    AN              shift and go to state 173
    YR              shift and go to state 67


state 130

    (90) expr -> EITHER OF expr . AN expr
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    AN              shift and go to state 174
    YR              shift and go to state 67


state 131

    (91) expr -> WON OF expr . AN expr
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    AN              shift and go to state 175
    YR              shift and go to state 67


state 132

    (93) expr -> ALL OF sep_args . MKAY
    (48) sep_args -> sep_args . AN expr

    MKAY            shift and go to state 176
    AN              shift and go to state 138


state 133

    (95) expr -> ALL OF args . MKAY
    (46) args -> args . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    MKAY            shift and go to state 177
    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 140
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 134

    (94) expr -> ANY OF sep_args . MKAY
    (48) sep_args -> sep_args . AN expr

    MKAY            shift and go to state 178
    AN              shift and go to state 138


state 135

    (96) expr -> ANY OF args . MKAY
    (46) args -> args . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    MKAY            shift and go to state 179
    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 140
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 136

    (98) expr -> DIFFRINT expr AN . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 180
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 137

    (99) expr -> SMOOSH sep_args MKAY .

    YR              reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    NEWLINE         reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    COMMA           reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    AN              reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    MKAY            reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    I               reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    SIZE            reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    ABSLUT          reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    BINRY           reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    SUM             reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    DIFF            reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    PRODUKT         reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    QUOSHUNT        reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    MOD             reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    BIGGR           reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    SMALLR          reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    BOTH            reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    EITHER          reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    WON             reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    NOT             reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    ALL             reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    ANY             reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    DIFFRINT        reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    SMOOSH          reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    MAEK            reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    ID              reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    IT              reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    STRING          reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    FLOAT           reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    INTEGER         reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    WIN             reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    FAIL            reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    DICT            reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    A               reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    YARN            reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    NUMBR           reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    NUMBAR          reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    NOOB            reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    BUKKIT          reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)
    EXCLAMATION     reduce using rule 99 (expr -> SMOOSH sep_args MKAY .)


state 138

    (48) sep_args -> sep_args AN . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 181
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 139

    (100) expr -> SMOOSH args MKAY .

    YR              reduce using rule 100 (expr -> SMOOSH args MKAY .)
    NEWLINE         reduce using rule 100 (expr -> SMOOSH args MKAY .)
    COMMA           reduce using rule 100 (expr -> SMOOSH args MKAY .)
    AN              reduce using rule 100 (expr -> SMOOSH args MKAY .)
    MKAY            reduce using rule 100 (expr -> SMOOSH args MKAY .)
    I               reduce using rule 100 (expr -> SMOOSH args MKAY .)
    SIZE            reduce using rule 100 (expr -> SMOOSH args MKAY .)
    ABSLUT          reduce using rule 100 (expr -> SMOOSH args MKAY .)
    BINRY           reduce using rule 100 (expr -> SMOOSH args MKAY .)
    SUM             reduce using rule 100 (expr -> SMOOSH args MKAY .)
    DIFF            reduce using rule 100 (expr -> SMOOSH args MKAY .)
    PRODUKT         reduce using rule 100 (expr -> SMOOSH args MKAY .)
    QUOSHUNT        reduce using rule 100 (expr -> SMOOSH args MKAY .)
    MOD             reduce using rule 100 (expr -> SMOOSH args MKAY .)
    BIGGR           reduce using rule 100 (expr -> SMOOSH args MKAY .)
    SMALLR          reduce using rule 100 (expr -> SMOOSH args MKAY .)
    BOTH            reduce using rule 100 (expr -> SMOOSH args MKAY .)
    EITHER          reduce using rule 100 (expr -> SMOOSH args MKAY .)
    WON             reduce using rule 100 (expr -> SMOOSH args MKAY .)
    NOT             reduce using rule 100 (expr -> SMOOSH args MKAY .)
    ALL             reduce using rule 100 (expr -> SMOOSH args MKAY .)
    ANY             reduce using rule 100 (expr -> SMOOSH args MKAY .)
    DIFFRINT        reduce using rule 100 (expr -> SMOOSH args MKAY .)
    SMOOSH          reduce using rule 100 (expr -> SMOOSH args MKAY .)
    MAEK            reduce using rule 100 (expr -> SMOOSH args MKAY .)
    ID              reduce using rule 100 (expr -> SMOOSH args MKAY .)
    IT              reduce using rule 100 (expr -> SMOOSH args MKAY .)
    STRING          reduce using rule 100 (expr -> SMOOSH args MKAY .)
    FLOAT           reduce using rule 100 (expr -> SMOOSH args MKAY .)
    INTEGER         reduce using rule 100 (expr -> SMOOSH args MKAY .)
    WIN             reduce using rule 100 (expr -> SMOOSH args MKAY .)
    FAIL            reduce using rule 100 (expr -> SMOOSH args MKAY .)
    DICT            reduce using rule 100 (expr -> SMOOSH args MKAY .)
    A               reduce using rule 100 (expr -> SMOOSH args MKAY .)
    YARN            reduce using rule 100 (expr -> SMOOSH args MKAY .)
    NUMBR           reduce using rule 100 (expr -> SMOOSH args MKAY .)
    NUMBAR          reduce using rule 100 (expr -> SMOOSH args MKAY .)
    NOOB            reduce using rule 100 (expr -> SMOOSH args MKAY .)
    BUKKIT          reduce using rule 100 (expr -> SMOOSH args MKAY .)
    EXCLAMATION     reduce using rule 100 (expr -> SMOOSH args MKAY .)


state 140

    (46) args -> args expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    MKAY            reduce using rule 46 (args -> args expr .)
    I               reduce using rule 46 (args -> args expr .)
    SIZE            reduce using rule 46 (args -> args expr .)
    ABSLUT          reduce using rule 46 (args -> args expr .)
    BINRY           reduce using rule 46 (args -> args expr .)
    SUM             reduce using rule 46 (args -> args expr .)
    DIFF            reduce using rule 46 (args -> args expr .)
    PRODUKT         reduce using rule 46 (args -> args expr .)
    QUOSHUNT        reduce using rule 46 (args -> args expr .)
    MOD             reduce using rule 46 (args -> args expr .)
    BIGGR           reduce using rule 46 (args -> args expr .)
    SMALLR          reduce using rule 46 (args -> args expr .)
    BOTH            reduce using rule 46 (args -> args expr .)
    EITHER          reduce using rule 46 (args -> args expr .)
    WON             reduce using rule 46 (args -> args expr .)
    NOT             reduce using rule 46 (args -> args expr .)
    ALL             reduce using rule 46 (args -> args expr .)
    ANY             reduce using rule 46 (args -> args expr .)
    DIFFRINT        reduce using rule 46 (args -> args expr .)
    SMOOSH          reduce using rule 46 (args -> args expr .)
    MAEK            reduce using rule 46 (args -> args expr .)
    ID              reduce using rule 46 (args -> args expr .)
    IT              reduce using rule 46 (args -> args expr .)
    STRING          reduce using rule 46 (args -> args expr .)
    FLOAT           reduce using rule 46 (args -> args expr .)
    INTEGER         reduce using rule 46 (args -> args expr .)
    WIN             reduce using rule 46 (args -> args expr .)
    FAIL            reduce using rule 46 (args -> args expr .)
    DICT            reduce using rule 46 (args -> args expr .)
    EXCLAMATION     reduce using rule 46 (args -> args expr .)
    NEWLINE         reduce using rule 46 (args -> args expr .)
    COMMA           reduce using rule 46 (args -> args expr .)
    YR              shift and go to state 67


state 141

    (101) expr -> MAEK expr A . type
    (62) type -> . YARN
    (63) type -> . NUMBR
    (64) type -> . NUMBAR
    (65) type -> . NOOB
    (66) type -> . BUKKIT

    YARN            shift and go to state 143
    NUMBR           shift and go to state 144
    NUMBAR          shift and go to state 145
    NOOB            shift and go to state 146
    BUKKIT          shift and go to state 147

    type                           shift and go to state 182

state 142

    (102) expr -> MAEK expr type .

    YR              reduce using rule 102 (expr -> MAEK expr type .)
    NEWLINE         reduce using rule 102 (expr -> MAEK expr type .)
    COMMA           reduce using rule 102 (expr -> MAEK expr type .)
    AN              reduce using rule 102 (expr -> MAEK expr type .)
    MKAY            reduce using rule 102 (expr -> MAEK expr type .)
    I               reduce using rule 102 (expr -> MAEK expr type .)
    SIZE            reduce using rule 102 (expr -> MAEK expr type .)
    ABSLUT          reduce using rule 102 (expr -> MAEK expr type .)
    BINRY           reduce using rule 102 (expr -> MAEK expr type .)
    SUM             reduce using rule 102 (expr -> MAEK expr type .)
    DIFF            reduce using rule 102 (expr -> MAEK expr type .)
    PRODUKT         reduce using rule 102 (expr -> MAEK expr type .)
    QUOSHUNT        reduce using rule 102 (expr -> MAEK expr type .)
    MOD             reduce using rule 102 (expr -> MAEK expr type .)
    BIGGR           reduce using rule 102 (expr -> MAEK expr type .)
    SMALLR          reduce using rule 102 (expr -> MAEK expr type .)
    BOTH            reduce using rule 102 (expr -> MAEK expr type .)
    EITHER          reduce using rule 102 (expr -> MAEK expr type .)
    WON             reduce using rule 102 (expr -> MAEK expr type .)
    NOT             reduce using rule 102 (expr -> MAEK expr type .)
    ALL             reduce using rule 102 (expr -> MAEK expr type .)
    ANY             reduce using rule 102 (expr -> MAEK expr type .)
    DIFFRINT        reduce using rule 102 (expr -> MAEK expr type .)
    SMOOSH          reduce using rule 102 (expr -> MAEK expr type .)
    MAEK            reduce using rule 102 (expr -> MAEK expr type .)
    ID              reduce using rule 102 (expr -> MAEK expr type .)
    IT              reduce using rule 102 (expr -> MAEK expr type .)
    STRING          reduce using rule 102 (expr -> MAEK expr type .)
    FLOAT           reduce using rule 102 (expr -> MAEK expr type .)
    INTEGER         reduce using rule 102 (expr -> MAEK expr type .)
    WIN             reduce using rule 102 (expr -> MAEK expr type .)
    FAIL            reduce using rule 102 (expr -> MAEK expr type .)
    DICT            reduce using rule 102 (expr -> MAEK expr type .)
    A               reduce using rule 102 (expr -> MAEK expr type .)
    YARN            reduce using rule 102 (expr -> MAEK expr type .)
    NUMBR           reduce using rule 102 (expr -> MAEK expr type .)
    NUMBAR          reduce using rule 102 (expr -> MAEK expr type .)
    NOOB            reduce using rule 102 (expr -> MAEK expr type .)
    BUKKIT          reduce using rule 102 (expr -> MAEK expr type .)
    EXCLAMATION     reduce using rule 102 (expr -> MAEK expr type .)


state 143

    (62) type -> YARN .

    YR              reduce using rule 62 (type -> YARN .)
    NEWLINE         reduce using rule 62 (type -> YARN .)
    COMMA           reduce using rule 62 (type -> YARN .)
    AN              reduce using rule 62 (type -> YARN .)
    MKAY            reduce using rule 62 (type -> YARN .)
    I               reduce using rule 62 (type -> YARN .)
    SIZE            reduce using rule 62 (type -> YARN .)
    ABSLUT          reduce using rule 62 (type -> YARN .)
    BINRY           reduce using rule 62 (type -> YARN .)
    SUM             reduce using rule 62 (type -> YARN .)
    DIFF            reduce using rule 62 (type -> YARN .)
    PRODUKT         reduce using rule 62 (type -> YARN .)
    QUOSHUNT        reduce using rule 62 (type -> YARN .)
    MOD             reduce using rule 62 (type -> YARN .)
    BIGGR           reduce using rule 62 (type -> YARN .)
    SMALLR          reduce using rule 62 (type -> YARN .)
    BOTH            reduce using rule 62 (type -> YARN .)
    EITHER          reduce using rule 62 (type -> YARN .)
    WON             reduce using rule 62 (type -> YARN .)
    NOT             reduce using rule 62 (type -> YARN .)
    ALL             reduce using rule 62 (type -> YARN .)
    ANY             reduce using rule 62 (type -> YARN .)
    DIFFRINT        reduce using rule 62 (type -> YARN .)
    SMOOSH          reduce using rule 62 (type -> YARN .)
    MAEK            reduce using rule 62 (type -> YARN .)
    ID              reduce using rule 62 (type -> YARN .)
    IT              reduce using rule 62 (type -> YARN .)
    STRING          reduce using rule 62 (type -> YARN .)
    FLOAT           reduce using rule 62 (type -> YARN .)
    INTEGER         reduce using rule 62 (type -> YARN .)
    WIN             reduce using rule 62 (type -> YARN .)
    FAIL            reduce using rule 62 (type -> YARN .)
    DICT            reduce using rule 62 (type -> YARN .)
    A               reduce using rule 62 (type -> YARN .)
    YARN            reduce using rule 62 (type -> YARN .)
    NUMBR           reduce using rule 62 (type -> YARN .)
    NUMBAR          reduce using rule 62 (type -> YARN .)
    NOOB            reduce using rule 62 (type -> YARN .)
    BUKKIT          reduce using rule 62 (type -> YARN .)
    EXCLAMATION     reduce using rule 62 (type -> YARN .)


state 144

    (63) type -> NUMBR .

    YR              reduce using rule 63 (type -> NUMBR .)
    NEWLINE         reduce using rule 63 (type -> NUMBR .)
    COMMA           reduce using rule 63 (type -> NUMBR .)
    AN              reduce using rule 63 (type -> NUMBR .)
    MKAY            reduce using rule 63 (type -> NUMBR .)
    I               reduce using rule 63 (type -> NUMBR .)
    SIZE            reduce using rule 63 (type -> NUMBR .)
    ABSLUT          reduce using rule 63 (type -> NUMBR .)
    BINRY           reduce using rule 63 (type -> NUMBR .)
    SUM             reduce using rule 63 (type -> NUMBR .)
    DIFF            reduce using rule 63 (type -> NUMBR .)
    PRODUKT         reduce using rule 63 (type -> NUMBR .)
    QUOSHUNT        reduce using rule 63 (type -> NUMBR .)
    MOD             reduce using rule 63 (type -> NUMBR .)
    BIGGR           reduce using rule 63 (type -> NUMBR .)
    SMALLR          reduce using rule 63 (type -> NUMBR .)
    BOTH            reduce using rule 63 (type -> NUMBR .)
    EITHER          reduce using rule 63 (type -> NUMBR .)
    WON             reduce using rule 63 (type -> NUMBR .)
    NOT             reduce using rule 63 (type -> NUMBR .)
    ALL             reduce using rule 63 (type -> NUMBR .)
    ANY             reduce using rule 63 (type -> NUMBR .)
    DIFFRINT        reduce using rule 63 (type -> NUMBR .)
    SMOOSH          reduce using rule 63 (type -> NUMBR .)
    MAEK            reduce using rule 63 (type -> NUMBR .)
    ID              reduce using rule 63 (type -> NUMBR .)
    IT              reduce using rule 63 (type -> NUMBR .)
    STRING          reduce using rule 63 (type -> NUMBR .)
    FLOAT           reduce using rule 63 (type -> NUMBR .)
    INTEGER         reduce using rule 63 (type -> NUMBR .)
    WIN             reduce using rule 63 (type -> NUMBR .)
    FAIL            reduce using rule 63 (type -> NUMBR .)
    DICT            reduce using rule 63 (type -> NUMBR .)
    A               reduce using rule 63 (type -> NUMBR .)
    YARN            reduce using rule 63 (type -> NUMBR .)
    NUMBR           reduce using rule 63 (type -> NUMBR .)
    NUMBAR          reduce using rule 63 (type -> NUMBR .)
    NOOB            reduce using rule 63 (type -> NUMBR .)
    BUKKIT          reduce using rule 63 (type -> NUMBR .)
    EXCLAMATION     reduce using rule 63 (type -> NUMBR .)


state 145

    (64) type -> NUMBAR .

    YR              reduce using rule 64 (type -> NUMBAR .)
    NEWLINE         reduce using rule 64 (type -> NUMBAR .)
    COMMA           reduce using rule 64 (type -> NUMBAR .)
    AN              reduce using rule 64 (type -> NUMBAR .)
    MKAY            reduce using rule 64 (type -> NUMBAR .)
    I               reduce using rule 64 (type -> NUMBAR .)
    SIZE            reduce using rule 64 (type -> NUMBAR .)
    ABSLUT          reduce using rule 64 (type -> NUMBAR .)
    BINRY           reduce using rule 64 (type -> NUMBAR .)
    SUM             reduce using rule 64 (type -> NUMBAR .)
    DIFF            reduce using rule 64 (type -> NUMBAR .)
    PRODUKT         reduce using rule 64 (type -> NUMBAR .)
    QUOSHUNT        reduce using rule 64 (type -> NUMBAR .)
    MOD             reduce using rule 64 (type -> NUMBAR .)
    BIGGR           reduce using rule 64 (type -> NUMBAR .)
    SMALLR          reduce using rule 64 (type -> NUMBAR .)
    BOTH            reduce using rule 64 (type -> NUMBAR .)
    EITHER          reduce using rule 64 (type -> NUMBAR .)
    WON             reduce using rule 64 (type -> NUMBAR .)
    NOT             reduce using rule 64 (type -> NUMBAR .)
    ALL             reduce using rule 64 (type -> NUMBAR .)
    ANY             reduce using rule 64 (type -> NUMBAR .)
    DIFFRINT        reduce using rule 64 (type -> NUMBAR .)
    SMOOSH          reduce using rule 64 (type -> NUMBAR .)
    MAEK            reduce using rule 64 (type -> NUMBAR .)
    ID              reduce using rule 64 (type -> NUMBAR .)
    IT              reduce using rule 64 (type -> NUMBAR .)
    STRING          reduce using rule 64 (type -> NUMBAR .)
    FLOAT           reduce using rule 64 (type -> NUMBAR .)
    INTEGER         reduce using rule 64 (type -> NUMBAR .)
    WIN             reduce using rule 64 (type -> NUMBAR .)
    FAIL            reduce using rule 64 (type -> NUMBAR .)
    DICT            reduce using rule 64 (type -> NUMBAR .)
    A               reduce using rule 64 (type -> NUMBAR .)
    YARN            reduce using rule 64 (type -> NUMBAR .)
    NUMBR           reduce using rule 64 (type -> NUMBAR .)
    NUMBAR          reduce using rule 64 (type -> NUMBAR .)
    NOOB            reduce using rule 64 (type -> NUMBAR .)
    BUKKIT          reduce using rule 64 (type -> NUMBAR .)
    EXCLAMATION     reduce using rule 64 (type -> NUMBAR .)


state 146

    (65) type -> NOOB .

    YR              reduce using rule 65 (type -> NOOB .)
    NEWLINE         reduce using rule 65 (type -> NOOB .)
    COMMA           reduce using rule 65 (type -> NOOB .)
    AN              reduce using rule 65 (type -> NOOB .)
    MKAY            reduce using rule 65 (type -> NOOB .)
    I               reduce using rule 65 (type -> NOOB .)
    SIZE            reduce using rule 65 (type -> NOOB .)
    ABSLUT          reduce using rule 65 (type -> NOOB .)
    BINRY           reduce using rule 65 (type -> NOOB .)
    SUM             reduce using rule 65 (type -> NOOB .)
    DIFF            reduce using rule 65 (type -> NOOB .)
    PRODUKT         reduce using rule 65 (type -> NOOB .)
    QUOSHUNT        reduce using rule 65 (type -> NOOB .)
    MOD             reduce using rule 65 (type -> NOOB .)
    BIGGR           reduce using rule 65 (type -> NOOB .)
    SMALLR          reduce using rule 65 (type -> NOOB .)
    BOTH            reduce using rule 65 (type -> NOOB .)
    EITHER          reduce using rule 65 (type -> NOOB .)
    WON             reduce using rule 65 (type -> NOOB .)
    NOT             reduce using rule 65 (type -> NOOB .)
    ALL             reduce using rule 65 (type -> NOOB .)
    ANY             reduce using rule 65 (type -> NOOB .)
    DIFFRINT        reduce using rule 65 (type -> NOOB .)
    SMOOSH          reduce using rule 65 (type -> NOOB .)
    MAEK            reduce using rule 65 (type -> NOOB .)
    ID              reduce using rule 65 (type -> NOOB .)
    IT              reduce using rule 65 (type -> NOOB .)
    STRING          reduce using rule 65 (type -> NOOB .)
    FLOAT           reduce using rule 65 (type -> NOOB .)
    INTEGER         reduce using rule 65 (type -> NOOB .)
    WIN             reduce using rule 65 (type -> NOOB .)
    FAIL            reduce using rule 65 (type -> NOOB .)
    DICT            reduce using rule 65 (type -> NOOB .)
    A               reduce using rule 65 (type -> NOOB .)
    YARN            reduce using rule 65 (type -> NOOB .)
    NUMBR           reduce using rule 65 (type -> NOOB .)
    NUMBAR          reduce using rule 65 (type -> NOOB .)
    NOOB            reduce using rule 65 (type -> NOOB .)
    BUKKIT          reduce using rule 65 (type -> NOOB .)
    EXCLAMATION     reduce using rule 65 (type -> NOOB .)


state 147

    (66) type -> BUKKIT .

    YR              reduce using rule 66 (type -> BUKKIT .)
    NEWLINE         reduce using rule 66 (type -> BUKKIT .)
    COMMA           reduce using rule 66 (type -> BUKKIT .)
    AN              reduce using rule 66 (type -> BUKKIT .)
    MKAY            reduce using rule 66 (type -> BUKKIT .)
    I               reduce using rule 66 (type -> BUKKIT .)
    SIZE            reduce using rule 66 (type -> BUKKIT .)
    ABSLUT          reduce using rule 66 (type -> BUKKIT .)
    BINRY           reduce using rule 66 (type -> BUKKIT .)
    SUM             reduce using rule 66 (type -> BUKKIT .)
    DIFF            reduce using rule 66 (type -> BUKKIT .)
    PRODUKT         reduce using rule 66 (type -> BUKKIT .)
    QUOSHUNT        reduce using rule 66 (type -> BUKKIT .)
    MOD             reduce using rule 66 (type -> BUKKIT .)
    BIGGR           reduce using rule 66 (type -> BUKKIT .)
    SMALLR          reduce using rule 66 (type -> BUKKIT .)
    BOTH            reduce using rule 66 (type -> BUKKIT .)
    EITHER          reduce using rule 66 (type -> BUKKIT .)
    WON             reduce using rule 66 (type -> BUKKIT .)
    NOT             reduce using rule 66 (type -> BUKKIT .)
    ALL             reduce using rule 66 (type -> BUKKIT .)
    ANY             reduce using rule 66 (type -> BUKKIT .)
    DIFFRINT        reduce using rule 66 (type -> BUKKIT .)
    SMOOSH          reduce using rule 66 (type -> BUKKIT .)
    MAEK            reduce using rule 66 (type -> BUKKIT .)
    ID              reduce using rule 66 (type -> BUKKIT .)
    IT              reduce using rule 66 (type -> BUKKIT .)
    STRING          reduce using rule 66 (type -> BUKKIT .)
    FLOAT           reduce using rule 66 (type -> BUKKIT .)
    INTEGER         reduce using rule 66 (type -> BUKKIT .)
    WIN             reduce using rule 66 (type -> BUKKIT .)
    FAIL            reduce using rule 66 (type -> BUKKIT .)
    DICT            reduce using rule 66 (type -> BUKKIT .)
    A               reduce using rule 66 (type -> BUKKIT .)
    YARN            reduce using rule 66 (type -> BUKKIT .)
    NUMBR           reduce using rule 66 (type -> BUKKIT .)
    NUMBAR          reduce using rule 66 (type -> BUKKIT .)
    NOOB            reduce using rule 66 (type -> BUKKIT .)
    BUKKIT          reduce using rule 66 (type -> BUKKIT .)
    EXCLAMATION     reduce using rule 66 (type -> BUKKIT .)


state 148

    (74) call -> VISIBLE args EXCLAMATION .

    NEWLINE         reduce using rule 74 (call -> VISIBLE args EXCLAMATION .)
    COMMA           reduce using rule 74 (call -> VISIBLE args EXCLAMATION .)


state 149

    (39) declare_bukkit_block -> O HAI IM . variable NEWLINE statements KTHX
    (103) variable -> . ID
    (104) variable -> . IT

    ID              shift and go to state 27
    IT              shift and go to state 57

    variable                       shift and go to state 183

state 150

    (29) if_else -> O RLY QUESTION . NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> O RLY QUESTION . NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> O RLY QUESTION . NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC

    NEWLINE         shift and go to state 184


state 151

    (21) loop -> IM IN YR . variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (103) variable -> . ID
    (104) variable -> . IT

    ID              shift and go to state 27
    IT              shift and go to state 57

    variable                       shift and go to state 185

state 152

    (52) bukkit_function -> HOW IZ variable . ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> HOW IZ variable . ID NEWLINE statements IF U SAY SO

    ID              shift and go to state 186


state 153

    (54) function -> HOW IZ I . ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> HOW IZ I . ID NEWLINE statements IF U SAY SO

    ID              shift and go to state 187


state 154

    (60) return -> FOUND YR expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    NEWLINE         reduce using rule 60 (return -> FOUND YR expr .)
    COMMA           reduce using rule 60 (return -> FOUND YR expr .)
    YR              shift and go to state 67


state 155

    (28) export -> YOU CAN HAS . sep_args MKAY
    (48) sep_args -> . sep_args AN expr
    (49) sep_args -> . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    sep_args                       shift and go to state 188
    expr                           shift and go to state 189
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 156

    (26) import -> CAN HAS PATH . QUESTION

    QUESTION        shift and go to state 190


state 157

    (27) import -> CAN HAS SNEK . PATH QUESTION

    PATH            shift and go to state 191


state 158

    (79) expr -> expr YR BASE ARE . BELONG TO expr

    BELONG          shift and go to state 192


state 159

    (58) expr -> variable IZ ID YR . sep_yr_args MKAY
    (50) sep_yr_args -> . sep_yr_args AN YR expr
    (51) sep_yr_args -> . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 90
    sep_yr_args                    shift and go to state 193
    expr                           shift and go to state 194
    value                          shift and go to state 31

state 160

    (43) cast -> variable IS NOW A . type
    (62) type -> . YARN
    (63) type -> . NUMBR
    (64) type -> . NUMBAR
    (65) type -> . NOOB
    (66) type -> . BUKKIT

    YARN            shift and go to state 143
    NUMBR           shift and go to state 144
    NUMBAR          shift and go to state 145
    NOOB            shift and go to state 146
    BUKKIT          shift and go to state 147

    type                           shift and go to state 195

state 161

    (44) cast -> variable R MAEK variable . A type
    (45) cast -> variable R MAEK variable . type
    (42) expr -> variable . APOSTROPHE_Z variable
    (58) expr -> variable . IZ ID YR sep_yr_args MKAY
    (59) expr -> variable . IZ ID
    (81) expr -> variable .
    (62) type -> . YARN
    (63) type -> . NUMBR
    (64) type -> . NUMBAR
    (65) type -> . NOOB
    (66) type -> . BUKKIT

  ! shift/reduce conflict for A resolved as shift
  ! shift/reduce conflict for YARN resolved as shift
  ! shift/reduce conflict for NUMBR resolved as shift
  ! shift/reduce conflict for NUMBAR resolved as shift
  ! shift/reduce conflict for NOOB resolved as shift
  ! shift/reduce conflict for BUKKIT resolved as shift
    A               shift and go to state 196
    APOSTROPHE_Z    shift and go to state 68
    IZ              shift and go to state 69
    YR              reduce using rule 81 (expr -> variable .)
    YARN            shift and go to state 143
    NUMBR           shift and go to state 144
    NUMBAR          shift and go to state 145
    NOOB            shift and go to state 146
    BUKKIT          shift and go to state 147

  ! A               [ reduce using rule 81 (expr -> variable .) ]
  ! YARN            [ reduce using rule 81 (expr -> variable .) ]
  ! NUMBR           [ reduce using rule 81 (expr -> variable .) ]
  ! NUMBAR          [ reduce using rule 81 (expr -> variable .) ]
  ! NOOB            [ reduce using rule 81 (expr -> variable .) ]
  ! BUKKIT          [ reduce using rule 81 (expr -> variable .) ]

    type                           shift and go to state 197

state 162

    (40) assign_bukkit -> variable HAS A variable . ITZ expr

    ITZ             shift and go to state 198


state 163

    (56) expr -> I IZ ID YR . sep_yr_args MKAY
    (50) sep_yr_args -> . sep_yr_args AN YR expr
    (51) sep_yr_args -> . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    sep_yr_args                    shift and go to state 199
    expr                           shift and go to state 194
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 164

    (35) decl -> I HAS A variable .
    (36) decl -> I HAS A variable . ITZ expr
    (37) decl -> I HAS A variable . ITZ A type
    (38) decl -> I HAS A variable . ITZ LIEK A variable

    NEWLINE         reduce using rule 35 (decl -> I HAS A variable .)
    COMMA           reduce using rule 35 (decl -> I HAS A variable .)
    ITZ             shift and go to state 200


state 165

    (82) expr -> SUM OF expr AN . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 201
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 166

    (83) expr -> DIFF OF expr AN . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 202
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 167

    (84) expr -> PRODUKT OF expr AN . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 203
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 168

    (85) expr -> QUOSHUNT OF expr AN . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 204
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 169

    (86) expr -> MOD OF expr AN . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 205
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 170

    (87) expr -> BIGGR OF expr AN . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 206
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 171

    (88) expr -> SMALLR OF expr AN . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 207
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 172

    (89) expr -> BOTH OF expr AN . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 208
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 173

    (97) expr -> BOTH SAEM expr AN . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 209
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 174

    (90) expr -> EITHER OF expr AN . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 210
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 175

    (91) expr -> WON OF expr AN . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 211
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 176

    (93) expr -> ALL OF sep_args MKAY .

    YR              reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    NEWLINE         reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    COMMA           reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    AN              reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    MKAY            reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    I               reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    SIZE            reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    ABSLUT          reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    BINRY           reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    SUM             reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    DIFF            reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    PRODUKT         reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    QUOSHUNT        reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    MOD             reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    BIGGR           reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    SMALLR          reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    BOTH            reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    EITHER          reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    WON             reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    NOT             reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    ALL             reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    ANY             reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    DIFFRINT        reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    SMOOSH          reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    MAEK            reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    ID              reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    IT              reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    STRING          reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    FLOAT           reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    INTEGER         reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    WIN             reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    FAIL            reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    DICT            reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    A               reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    YARN            reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    NUMBR           reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    NUMBAR          reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    NOOB            reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    BUKKIT          reduce using rule 93 (expr -> ALL OF sep_args MKAY .)
    EXCLAMATION     reduce using rule 93 (expr -> ALL OF sep_args MKAY .)


state 177

    (95) expr -> ALL OF args MKAY .

    YR              reduce using rule 95 (expr -> ALL OF args MKAY .)
    NEWLINE         reduce using rule 95 (expr -> ALL OF args MKAY .)
    COMMA           reduce using rule 95 (expr -> ALL OF args MKAY .)
    AN              reduce using rule 95 (expr -> ALL OF args MKAY .)
    MKAY            reduce using rule 95 (expr -> ALL OF args MKAY .)
    I               reduce using rule 95 (expr -> ALL OF args MKAY .)
    SIZE            reduce using rule 95 (expr -> ALL OF args MKAY .)
    ABSLUT          reduce using rule 95 (expr -> ALL OF args MKAY .)
    BINRY           reduce using rule 95 (expr -> ALL OF args MKAY .)
    SUM             reduce using rule 95 (expr -> ALL OF args MKAY .)
    DIFF            reduce using rule 95 (expr -> ALL OF args MKAY .)
    PRODUKT         reduce using rule 95 (expr -> ALL OF args MKAY .)
    QUOSHUNT        reduce using rule 95 (expr -> ALL OF args MKAY .)
    MOD             reduce using rule 95 (expr -> ALL OF args MKAY .)
    BIGGR           reduce using rule 95 (expr -> ALL OF args MKAY .)
    SMALLR          reduce using rule 95 (expr -> ALL OF args MKAY .)
    BOTH            reduce using rule 95 (expr -> ALL OF args MKAY .)
    EITHER          reduce using rule 95 (expr -> ALL OF args MKAY .)
    WON             reduce using rule 95 (expr -> ALL OF args MKAY .)
    NOT             reduce using rule 95 (expr -> ALL OF args MKAY .)
    ALL             reduce using rule 95 (expr -> ALL OF args MKAY .)
    ANY             reduce using rule 95 (expr -> ALL OF args MKAY .)
    DIFFRINT        reduce using rule 95 (expr -> ALL OF args MKAY .)
    SMOOSH          reduce using rule 95 (expr -> ALL OF args MKAY .)
    MAEK            reduce using rule 95 (expr -> ALL OF args MKAY .)
    ID              reduce using rule 95 (expr -> ALL OF args MKAY .)
    IT              reduce using rule 95 (expr -> ALL OF args MKAY .)
    STRING          reduce using rule 95 (expr -> ALL OF args MKAY .)
    FLOAT           reduce using rule 95 (expr -> ALL OF args MKAY .)
    INTEGER         reduce using rule 95 (expr -> ALL OF args MKAY .)
    WIN             reduce using rule 95 (expr -> ALL OF args MKAY .)
    FAIL            reduce using rule 95 (expr -> ALL OF args MKAY .)
    DICT            reduce using rule 95 (expr -> ALL OF args MKAY .)
    A               reduce using rule 95 (expr -> ALL OF args MKAY .)
    YARN            reduce using rule 95 (expr -> ALL OF args MKAY .)
    NUMBR           reduce using rule 95 (expr -> ALL OF args MKAY .)
    NUMBAR          reduce using rule 95 (expr -> ALL OF args MKAY .)
    NOOB            reduce using rule 95 (expr -> ALL OF args MKAY .)
    BUKKIT          reduce using rule 95 (expr -> ALL OF args MKAY .)
    EXCLAMATION     reduce using rule 95 (expr -> ALL OF args MKAY .)


state 178

    (94) expr -> ANY OF sep_args MKAY .

    YR              reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    NEWLINE         reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    COMMA           reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    AN              reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    MKAY            reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    I               reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    SIZE            reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    ABSLUT          reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    BINRY           reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    SUM             reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    DIFF            reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    PRODUKT         reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    QUOSHUNT        reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    MOD             reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    BIGGR           reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    SMALLR          reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    BOTH            reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    EITHER          reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    WON             reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    NOT             reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    ALL             reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    ANY             reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    DIFFRINT        reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    SMOOSH          reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    MAEK            reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    ID              reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    IT              reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    STRING          reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    FLOAT           reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    INTEGER         reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    WIN             reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    FAIL            reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    DICT            reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    A               reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    YARN            reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    NUMBR           reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    NUMBAR          reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    NOOB            reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    BUKKIT          reduce using rule 94 (expr -> ANY OF sep_args MKAY .)
    EXCLAMATION     reduce using rule 94 (expr -> ANY OF sep_args MKAY .)


state 179

    (96) expr -> ANY OF args MKAY .

    YR              reduce using rule 96 (expr -> ANY OF args MKAY .)
    NEWLINE         reduce using rule 96 (expr -> ANY OF args MKAY .)
    COMMA           reduce using rule 96 (expr -> ANY OF args MKAY .)
    AN              reduce using rule 96 (expr -> ANY OF args MKAY .)
    MKAY            reduce using rule 96 (expr -> ANY OF args MKAY .)
    I               reduce using rule 96 (expr -> ANY OF args MKAY .)
    SIZE            reduce using rule 96 (expr -> ANY OF args MKAY .)
    ABSLUT          reduce using rule 96 (expr -> ANY OF args MKAY .)
    BINRY           reduce using rule 96 (expr -> ANY OF args MKAY .)
    SUM             reduce using rule 96 (expr -> ANY OF args MKAY .)
    DIFF            reduce using rule 96 (expr -> ANY OF args MKAY .)
    PRODUKT         reduce using rule 96 (expr -> ANY OF args MKAY .)
    QUOSHUNT        reduce using rule 96 (expr -> ANY OF args MKAY .)
    MOD             reduce using rule 96 (expr -> ANY OF args MKAY .)
    BIGGR           reduce using rule 96 (expr -> ANY OF args MKAY .)
    SMALLR          reduce using rule 96 (expr -> ANY OF args MKAY .)
    BOTH            reduce using rule 96 (expr -> ANY OF args MKAY .)
    EITHER          reduce using rule 96 (expr -> ANY OF args MKAY .)
    WON             reduce using rule 96 (expr -> ANY OF args MKAY .)
    NOT             reduce using rule 96 (expr -> ANY OF args MKAY .)
    ALL             reduce using rule 96 (expr -> ANY OF args MKAY .)
    ANY             reduce using rule 96 (expr -> ANY OF args MKAY .)
    DIFFRINT        reduce using rule 96 (expr -> ANY OF args MKAY .)
    SMOOSH          reduce using rule 96 (expr -> ANY OF args MKAY .)
    MAEK            reduce using rule 96 (expr -> ANY OF args MKAY .)
    ID              reduce using rule 96 (expr -> ANY OF args MKAY .)
    IT              reduce using rule 96 (expr -> ANY OF args MKAY .)
    STRING          reduce using rule 96 (expr -> ANY OF args MKAY .)
    FLOAT           reduce using rule 96 (expr -> ANY OF args MKAY .)
    INTEGER         reduce using rule 96 (expr -> ANY OF args MKAY .)
    WIN             reduce using rule 96 (expr -> ANY OF args MKAY .)
    FAIL            reduce using rule 96 (expr -> ANY OF args MKAY .)
    DICT            reduce using rule 96 (expr -> ANY OF args MKAY .)
    A               reduce using rule 96 (expr -> ANY OF args MKAY .)
    YARN            reduce using rule 96 (expr -> ANY OF args MKAY .)
    NUMBR           reduce using rule 96 (expr -> ANY OF args MKAY .)
    NUMBAR          reduce using rule 96 (expr -> ANY OF args MKAY .)
    NOOB            reduce using rule 96 (expr -> ANY OF args MKAY .)
    BUKKIT          reduce using rule 96 (expr -> ANY OF args MKAY .)
    EXCLAMATION     reduce using rule 96 (expr -> ANY OF args MKAY .)


state 180

    (98) expr -> DIFFRINT expr AN expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    COMMA           reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    AN              reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    MKAY            reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    I               reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    SIZE            reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    ABSLUT          reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    BINRY           reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    SUM             reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    DIFF            reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    PRODUKT         reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    QUOSHUNT        reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    MOD             reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    BIGGR           reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    SMALLR          reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    BOTH            reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    EITHER          reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    WON             reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    NOT             reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    ALL             reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    ANY             reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    DIFFRINT        reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    SMOOSH          reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    MAEK            reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    ID              reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    IT              reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    STRING          reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    FLOAT           reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    INTEGER         reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    WIN             reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    FAIL            reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    DICT            reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    A               reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    YARN            reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    NUMBR           reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    NUMBAR          reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    NOOB            reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    BUKKIT          reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    EXCLAMATION     reduce using rule 98 (expr -> DIFFRINT expr AN expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 98 (expr -> DIFFRINT expr AN expr .) ]


state 181

    (48) sep_args -> sep_args AN expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    MKAY            reduce using rule 48 (sep_args -> sep_args AN expr .)
    AN              reduce using rule 48 (sep_args -> sep_args AN expr .)
    YR              shift and go to state 67


state 182

    (101) expr -> MAEK expr A type .

    YR              reduce using rule 101 (expr -> MAEK expr A type .)
    NEWLINE         reduce using rule 101 (expr -> MAEK expr A type .)
    COMMA           reduce using rule 101 (expr -> MAEK expr A type .)
    AN              reduce using rule 101 (expr -> MAEK expr A type .)
    MKAY            reduce using rule 101 (expr -> MAEK expr A type .)
    I               reduce using rule 101 (expr -> MAEK expr A type .)
    SIZE            reduce using rule 101 (expr -> MAEK expr A type .)
    ABSLUT          reduce using rule 101 (expr -> MAEK expr A type .)
    BINRY           reduce using rule 101 (expr -> MAEK expr A type .)
    SUM             reduce using rule 101 (expr -> MAEK expr A type .)
    DIFF            reduce using rule 101 (expr -> MAEK expr A type .)
    PRODUKT         reduce using rule 101 (expr -> MAEK expr A type .)
    QUOSHUNT        reduce using rule 101 (expr -> MAEK expr A type .)
    MOD             reduce using rule 101 (expr -> MAEK expr A type .)
    BIGGR           reduce using rule 101 (expr -> MAEK expr A type .)
    SMALLR          reduce using rule 101 (expr -> MAEK expr A type .)
    BOTH            reduce using rule 101 (expr -> MAEK expr A type .)
    EITHER          reduce using rule 101 (expr -> MAEK expr A type .)
    WON             reduce using rule 101 (expr -> MAEK expr A type .)
    NOT             reduce using rule 101 (expr -> MAEK expr A type .)
    ALL             reduce using rule 101 (expr -> MAEK expr A type .)
    ANY             reduce using rule 101 (expr -> MAEK expr A type .)
    DIFFRINT        reduce using rule 101 (expr -> MAEK expr A type .)
    SMOOSH          reduce using rule 101 (expr -> MAEK expr A type .)
    MAEK            reduce using rule 101 (expr -> MAEK expr A type .)
    ID              reduce using rule 101 (expr -> MAEK expr A type .)
    IT              reduce using rule 101 (expr -> MAEK expr A type .)
    STRING          reduce using rule 101 (expr -> MAEK expr A type .)
    FLOAT           reduce using rule 101 (expr -> MAEK expr A type .)
    INTEGER         reduce using rule 101 (expr -> MAEK expr A type .)
    WIN             reduce using rule 101 (expr -> MAEK expr A type .)
    FAIL            reduce using rule 101 (expr -> MAEK expr A type .)
    DICT            reduce using rule 101 (expr -> MAEK expr A type .)
    A               reduce using rule 101 (expr -> MAEK expr A type .)
    YARN            reduce using rule 101 (expr -> MAEK expr A type .)
    NUMBR           reduce using rule 101 (expr -> MAEK expr A type .)
    NUMBAR          reduce using rule 101 (expr -> MAEK expr A type .)
    NOOB            reduce using rule 101 (expr -> MAEK expr A type .)
    BUKKIT          reduce using rule 101 (expr -> MAEK expr A type .)
    EXCLAMATION     reduce using rule 101 (expr -> MAEK expr A type .)


state 183

    (39) declare_bukkit_block -> O HAI IM variable . NEWLINE statements KTHX

    NEWLINE         shift and go to state 212


state 184

    (29) if_else -> O RLY QUESTION NEWLINE . YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> O RLY QUESTION NEWLINE . YA RLY NEWLINE statements OIC
    (31) if_else -> O RLY QUESTION NEWLINE . YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC

    YA              shift and go to state 213


state 185

    (21) loop -> IM IN YR variable . operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (22) operation -> . UPPIN
    (23) operation -> . NERFIN

    UPPIN           shift and go to state 215
    NERFIN          shift and go to state 216

    operation                      shift and go to state 214

state 186

    (52) bukkit_function -> HOW IZ variable ID . YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> HOW IZ variable ID . NEWLINE statements IF U SAY SO

    YR              shift and go to state 217
    NEWLINE         shift and go to state 218


state 187

    (54) function -> HOW IZ I ID . YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> HOW IZ I ID . NEWLINE statements IF U SAY SO

    YR              shift and go to state 219
    NEWLINE         shift and go to state 220


state 188

    (28) export -> YOU CAN HAS sep_args . MKAY
    (48) sep_args -> sep_args . AN expr

    MKAY            shift and go to state 221
    AN              shift and go to state 138


state 189

    (49) sep_args -> expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    MKAY            reduce using rule 49 (sep_args -> expr .)
    AN              reduce using rule 49 (sep_args -> expr .)
    YR              shift and go to state 67


state 190

    (26) import -> CAN HAS PATH QUESTION .

    NEWLINE         reduce using rule 26 (import -> CAN HAS PATH QUESTION .)
    COMMA           reduce using rule 26 (import -> CAN HAS PATH QUESTION .)


state 191

    (27) import -> CAN HAS SNEK PATH . QUESTION

    QUESTION        shift and go to state 222


state 192

    (79) expr -> expr YR BASE ARE BELONG . TO expr

    TO              shift and go to state 223


state 193

    (58) expr -> variable IZ ID YR sep_yr_args . MKAY
    (50) sep_yr_args -> sep_yr_args . AN YR expr

    MKAY            shift and go to state 224
    AN              shift and go to state 225


state 194

    (51) sep_yr_args -> expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    MKAY            reduce using rule 51 (sep_yr_args -> expr .)
    AN              reduce using rule 51 (sep_yr_args -> expr .)
    NEWLINE         reduce using rule 51 (sep_yr_args -> expr .)
    YR              shift and go to state 67


state 195

    (43) cast -> variable IS NOW A type .

    NEWLINE         reduce using rule 43 (cast -> variable IS NOW A type .)
    COMMA           reduce using rule 43 (cast -> variable IS NOW A type .)


state 196

    (44) cast -> variable R MAEK variable A . type
    (62) type -> . YARN
    (63) type -> . NUMBR
    (64) type -> . NUMBAR
    (65) type -> . NOOB
    (66) type -> . BUKKIT

    YARN            shift and go to state 143
    NUMBR           shift and go to state 144
    NUMBAR          shift and go to state 145
    NOOB            shift and go to state 146
    BUKKIT          shift and go to state 147

    type                           shift and go to state 226

state 197

    (45) cast -> variable R MAEK variable type .

    NEWLINE         reduce using rule 45 (cast -> variable R MAEK variable type .)
    COMMA           reduce using rule 45 (cast -> variable R MAEK variable type .)


state 198

    (40) assign_bukkit -> variable HAS A variable ITZ . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 90
    expr                           shift and go to state 227
    value                          shift and go to state 31

state 199

    (56) expr -> I IZ ID YR sep_yr_args . MKAY
    (50) sep_yr_args -> sep_yr_args . AN YR expr

    MKAY            shift and go to state 228
    AN              shift and go to state 225


state 200

    (36) decl -> I HAS A variable ITZ . expr
    (37) decl -> I HAS A variable ITZ . A type
    (38) decl -> I HAS A variable ITZ . LIEK A variable
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    A               shift and go to state 229
    LIEK            shift and go to state 231
    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 90
    expr                           shift and go to state 230
    value                          shift and go to state 31

state 201

    (82) expr -> SUM OF expr AN expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 82 (expr -> SUM OF expr AN expr .)
    COMMA           reduce using rule 82 (expr -> SUM OF expr AN expr .)
    AN              reduce using rule 82 (expr -> SUM OF expr AN expr .)
    MKAY            reduce using rule 82 (expr -> SUM OF expr AN expr .)
    I               reduce using rule 82 (expr -> SUM OF expr AN expr .)
    SIZE            reduce using rule 82 (expr -> SUM OF expr AN expr .)
    ABSLUT          reduce using rule 82 (expr -> SUM OF expr AN expr .)
    BINRY           reduce using rule 82 (expr -> SUM OF expr AN expr .)
    SUM             reduce using rule 82 (expr -> SUM OF expr AN expr .)
    DIFF            reduce using rule 82 (expr -> SUM OF expr AN expr .)
    PRODUKT         reduce using rule 82 (expr -> SUM OF expr AN expr .)
    QUOSHUNT        reduce using rule 82 (expr -> SUM OF expr AN expr .)
    MOD             reduce using rule 82 (expr -> SUM OF expr AN expr .)
    BIGGR           reduce using rule 82 (expr -> SUM OF expr AN expr .)
    SMALLR          reduce using rule 82 (expr -> SUM OF expr AN expr .)
    BOTH            reduce using rule 82 (expr -> SUM OF expr AN expr .)
    EITHER          reduce using rule 82 (expr -> SUM OF expr AN expr .)
    WON             reduce using rule 82 (expr -> SUM OF expr AN expr .)
    NOT             reduce using rule 82 (expr -> SUM OF expr AN expr .)
    ALL             reduce using rule 82 (expr -> SUM OF expr AN expr .)
    ANY             reduce using rule 82 (expr -> SUM OF expr AN expr .)
    DIFFRINT        reduce using rule 82 (expr -> SUM OF expr AN expr .)
    SMOOSH          reduce using rule 82 (expr -> SUM OF expr AN expr .)
    MAEK            reduce using rule 82 (expr -> SUM OF expr AN expr .)
    ID              reduce using rule 82 (expr -> SUM OF expr AN expr .)
    IT              reduce using rule 82 (expr -> SUM OF expr AN expr .)
    STRING          reduce using rule 82 (expr -> SUM OF expr AN expr .)
    FLOAT           reduce using rule 82 (expr -> SUM OF expr AN expr .)
    INTEGER         reduce using rule 82 (expr -> SUM OF expr AN expr .)
    WIN             reduce using rule 82 (expr -> SUM OF expr AN expr .)
    FAIL            reduce using rule 82 (expr -> SUM OF expr AN expr .)
    DICT            reduce using rule 82 (expr -> SUM OF expr AN expr .)
    A               reduce using rule 82 (expr -> SUM OF expr AN expr .)
    YARN            reduce using rule 82 (expr -> SUM OF expr AN expr .)
    NUMBR           reduce using rule 82 (expr -> SUM OF expr AN expr .)
    NUMBAR          reduce using rule 82 (expr -> SUM OF expr AN expr .)
    NOOB            reduce using rule 82 (expr -> SUM OF expr AN expr .)
    BUKKIT          reduce using rule 82 (expr -> SUM OF expr AN expr .)
    EXCLAMATION     reduce using rule 82 (expr -> SUM OF expr AN expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 82 (expr -> SUM OF expr AN expr .) ]


state 202

    (83) expr -> DIFF OF expr AN expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    COMMA           reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    AN              reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    MKAY            reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    I               reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    SIZE            reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    ABSLUT          reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    BINRY           reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    SUM             reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    DIFF            reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    PRODUKT         reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    QUOSHUNT        reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    MOD             reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    BIGGR           reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    SMALLR          reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    BOTH            reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    EITHER          reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    WON             reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    NOT             reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    ALL             reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    ANY             reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    DIFFRINT        reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    SMOOSH          reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    MAEK            reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    ID              reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    IT              reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    STRING          reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    FLOAT           reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    INTEGER         reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    WIN             reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    FAIL            reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    DICT            reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    A               reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    YARN            reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    NUMBR           reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    NUMBAR          reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    NOOB            reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    BUKKIT          reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    EXCLAMATION     reduce using rule 83 (expr -> DIFF OF expr AN expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 83 (expr -> DIFF OF expr AN expr .) ]


state 203

    (84) expr -> PRODUKT OF expr AN expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    COMMA           reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    AN              reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    MKAY            reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    I               reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    SIZE            reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    ABSLUT          reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    BINRY           reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    SUM             reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    DIFF            reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    PRODUKT         reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    QUOSHUNT        reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    MOD             reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    BIGGR           reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    SMALLR          reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    BOTH            reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    EITHER          reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    WON             reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    NOT             reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    ALL             reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    ANY             reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    DIFFRINT        reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    SMOOSH          reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    MAEK            reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    ID              reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    IT              reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    STRING          reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    FLOAT           reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    INTEGER         reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    WIN             reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    FAIL            reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    DICT            reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    A               reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    YARN            reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    NUMBR           reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    NUMBAR          reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    NOOB            reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    BUKKIT          reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    EXCLAMATION     reduce using rule 84 (expr -> PRODUKT OF expr AN expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 84 (expr -> PRODUKT OF expr AN expr .) ]


state 204

    (85) expr -> QUOSHUNT OF expr AN expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    COMMA           reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    AN              reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    MKAY            reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    I               reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    SIZE            reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    ABSLUT          reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    BINRY           reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    SUM             reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    DIFF            reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    PRODUKT         reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    QUOSHUNT        reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    MOD             reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    BIGGR           reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    SMALLR          reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    BOTH            reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    EITHER          reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    WON             reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    NOT             reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    ALL             reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    ANY             reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    DIFFRINT        reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    SMOOSH          reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    MAEK            reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    ID              reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    IT              reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    STRING          reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    FLOAT           reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    INTEGER         reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    WIN             reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    FAIL            reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    DICT            reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    A               reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    YARN            reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    NUMBR           reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    NUMBAR          reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    NOOB            reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    BUKKIT          reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    EXCLAMATION     reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 85 (expr -> QUOSHUNT OF expr AN expr .) ]


state 205

    (86) expr -> MOD OF expr AN expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 86 (expr -> MOD OF expr AN expr .)
    COMMA           reduce using rule 86 (expr -> MOD OF expr AN expr .)
    AN              reduce using rule 86 (expr -> MOD OF expr AN expr .)
    MKAY            reduce using rule 86 (expr -> MOD OF expr AN expr .)
    I               reduce using rule 86 (expr -> MOD OF expr AN expr .)
    SIZE            reduce using rule 86 (expr -> MOD OF expr AN expr .)
    ABSLUT          reduce using rule 86 (expr -> MOD OF expr AN expr .)
    BINRY           reduce using rule 86 (expr -> MOD OF expr AN expr .)
    SUM             reduce using rule 86 (expr -> MOD OF expr AN expr .)
    DIFF            reduce using rule 86 (expr -> MOD OF expr AN expr .)
    PRODUKT         reduce using rule 86 (expr -> MOD OF expr AN expr .)
    QUOSHUNT        reduce using rule 86 (expr -> MOD OF expr AN expr .)
    MOD             reduce using rule 86 (expr -> MOD OF expr AN expr .)
    BIGGR           reduce using rule 86 (expr -> MOD OF expr AN expr .)
    SMALLR          reduce using rule 86 (expr -> MOD OF expr AN expr .)
    BOTH            reduce using rule 86 (expr -> MOD OF expr AN expr .)
    EITHER          reduce using rule 86 (expr -> MOD OF expr AN expr .)
    WON             reduce using rule 86 (expr -> MOD OF expr AN expr .)
    NOT             reduce using rule 86 (expr -> MOD OF expr AN expr .)
    ALL             reduce using rule 86 (expr -> MOD OF expr AN expr .)
    ANY             reduce using rule 86 (expr -> MOD OF expr AN expr .)
    DIFFRINT        reduce using rule 86 (expr -> MOD OF expr AN expr .)
    SMOOSH          reduce using rule 86 (expr -> MOD OF expr AN expr .)
    MAEK            reduce using rule 86 (expr -> MOD OF expr AN expr .)
    ID              reduce using rule 86 (expr -> MOD OF expr AN expr .)
    IT              reduce using rule 86 (expr -> MOD OF expr AN expr .)
    STRING          reduce using rule 86 (expr -> MOD OF expr AN expr .)
    FLOAT           reduce using rule 86 (expr -> MOD OF expr AN expr .)
    INTEGER         reduce using rule 86 (expr -> MOD OF expr AN expr .)
    WIN             reduce using rule 86 (expr -> MOD OF expr AN expr .)
    FAIL            reduce using rule 86 (expr -> MOD OF expr AN expr .)
    DICT            reduce using rule 86 (expr -> MOD OF expr AN expr .)
    A               reduce using rule 86 (expr -> MOD OF expr AN expr .)
    YARN            reduce using rule 86 (expr -> MOD OF expr AN expr .)
    NUMBR           reduce using rule 86 (expr -> MOD OF expr AN expr .)
    NUMBAR          reduce using rule 86 (expr -> MOD OF expr AN expr .)
    NOOB            reduce using rule 86 (expr -> MOD OF expr AN expr .)
    BUKKIT          reduce using rule 86 (expr -> MOD OF expr AN expr .)
    EXCLAMATION     reduce using rule 86 (expr -> MOD OF expr AN expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 86 (expr -> MOD OF expr AN expr .) ]


state 206

    (87) expr -> BIGGR OF expr AN expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    COMMA           reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    AN              reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    MKAY            reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    I               reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    SIZE            reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    ABSLUT          reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    BINRY           reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    SUM             reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    DIFF            reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    PRODUKT         reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    QUOSHUNT        reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    MOD             reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    BIGGR           reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    SMALLR          reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    BOTH            reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    EITHER          reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    WON             reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    NOT             reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    ALL             reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    ANY             reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    DIFFRINT        reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    SMOOSH          reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    MAEK            reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    ID              reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    IT              reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    STRING          reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    FLOAT           reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    INTEGER         reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    WIN             reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    FAIL            reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    DICT            reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    A               reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    YARN            reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    NUMBR           reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    NUMBAR          reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    NOOB            reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    BUKKIT          reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    EXCLAMATION     reduce using rule 87 (expr -> BIGGR OF expr AN expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 87 (expr -> BIGGR OF expr AN expr .) ]


state 207

    (88) expr -> SMALLR OF expr AN expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    COMMA           reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    AN              reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    MKAY            reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    I               reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    SIZE            reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    ABSLUT          reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    BINRY           reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    SUM             reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    DIFF            reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    PRODUKT         reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    QUOSHUNT        reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    MOD             reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    BIGGR           reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    SMALLR          reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    BOTH            reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    EITHER          reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    WON             reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    NOT             reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    ALL             reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    ANY             reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    DIFFRINT        reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    SMOOSH          reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    MAEK            reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    ID              reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    IT              reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    STRING          reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    FLOAT           reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    INTEGER         reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    WIN             reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    FAIL            reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    DICT            reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    A               reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    YARN            reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    NUMBR           reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    NUMBAR          reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    NOOB            reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    BUKKIT          reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    EXCLAMATION     reduce using rule 88 (expr -> SMALLR OF expr AN expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 88 (expr -> SMALLR OF expr AN expr .) ]


state 208

    (89) expr -> BOTH OF expr AN expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    COMMA           reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    AN              reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    MKAY            reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    I               reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    SIZE            reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    ABSLUT          reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    BINRY           reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    SUM             reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    DIFF            reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    PRODUKT         reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    QUOSHUNT        reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    MOD             reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    BIGGR           reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    SMALLR          reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    BOTH            reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    EITHER          reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    WON             reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    NOT             reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    ALL             reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    ANY             reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    DIFFRINT        reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    SMOOSH          reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    MAEK            reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    ID              reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    IT              reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    STRING          reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    FLOAT           reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    INTEGER         reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    WIN             reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    FAIL            reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    DICT            reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    A               reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    YARN            reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    NUMBR           reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    NUMBAR          reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    NOOB            reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    BUKKIT          reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    EXCLAMATION     reduce using rule 89 (expr -> BOTH OF expr AN expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 89 (expr -> BOTH OF expr AN expr .) ]


state 209

    (97) expr -> BOTH SAEM expr AN expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    COMMA           reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    AN              reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    MKAY            reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    I               reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    SIZE            reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    ABSLUT          reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    BINRY           reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    SUM             reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    DIFF            reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    PRODUKT         reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    QUOSHUNT        reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    MOD             reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    BIGGR           reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    SMALLR          reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    BOTH            reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    EITHER          reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    WON             reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    NOT             reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    ALL             reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    ANY             reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    DIFFRINT        reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    SMOOSH          reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    MAEK            reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    ID              reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    IT              reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    STRING          reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    FLOAT           reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    INTEGER         reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    WIN             reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    FAIL            reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    DICT            reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    A               reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    YARN            reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    NUMBR           reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    NUMBAR          reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    NOOB            reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    BUKKIT          reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    EXCLAMATION     reduce using rule 97 (expr -> BOTH SAEM expr AN expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 97 (expr -> BOTH SAEM expr AN expr .) ]


state 210

    (90) expr -> EITHER OF expr AN expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    COMMA           reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    AN              reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    MKAY            reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    I               reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    SIZE            reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    ABSLUT          reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    BINRY           reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    SUM             reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    DIFF            reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    PRODUKT         reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    QUOSHUNT        reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    MOD             reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    BIGGR           reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    SMALLR          reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    BOTH            reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    EITHER          reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    WON             reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    NOT             reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    ALL             reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    ANY             reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    DIFFRINT        reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    SMOOSH          reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    MAEK            reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    ID              reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    IT              reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    STRING          reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    FLOAT           reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    INTEGER         reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    WIN             reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    FAIL            reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    DICT            reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    A               reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    YARN            reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    NUMBR           reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    NUMBAR          reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    NOOB            reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    BUKKIT          reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    EXCLAMATION     reduce using rule 90 (expr -> EITHER OF expr AN expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 90 (expr -> EITHER OF expr AN expr .) ]


state 211

    (91) expr -> WON OF expr AN expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 91 (expr -> WON OF expr AN expr .)
    COMMA           reduce using rule 91 (expr -> WON OF expr AN expr .)
    AN              reduce using rule 91 (expr -> WON OF expr AN expr .)
    MKAY            reduce using rule 91 (expr -> WON OF expr AN expr .)
    I               reduce using rule 91 (expr -> WON OF expr AN expr .)
    SIZE            reduce using rule 91 (expr -> WON OF expr AN expr .)
    ABSLUT          reduce using rule 91 (expr -> WON OF expr AN expr .)
    BINRY           reduce using rule 91 (expr -> WON OF expr AN expr .)
    SUM             reduce using rule 91 (expr -> WON OF expr AN expr .)
    DIFF            reduce using rule 91 (expr -> WON OF expr AN expr .)
    PRODUKT         reduce using rule 91 (expr -> WON OF expr AN expr .)
    QUOSHUNT        reduce using rule 91 (expr -> WON OF expr AN expr .)
    MOD             reduce using rule 91 (expr -> WON OF expr AN expr .)
    BIGGR           reduce using rule 91 (expr -> WON OF expr AN expr .)
    SMALLR          reduce using rule 91 (expr -> WON OF expr AN expr .)
    BOTH            reduce using rule 91 (expr -> WON OF expr AN expr .)
    EITHER          reduce using rule 91 (expr -> WON OF expr AN expr .)
    WON             reduce using rule 91 (expr -> WON OF expr AN expr .)
    NOT             reduce using rule 91 (expr -> WON OF expr AN expr .)
    ALL             reduce using rule 91 (expr -> WON OF expr AN expr .)
    ANY             reduce using rule 91 (expr -> WON OF expr AN expr .)
    DIFFRINT        reduce using rule 91 (expr -> WON OF expr AN expr .)
    SMOOSH          reduce using rule 91 (expr -> WON OF expr AN expr .)
    MAEK            reduce using rule 91 (expr -> WON OF expr AN expr .)
    ID              reduce using rule 91 (expr -> WON OF expr AN expr .)
    IT              reduce using rule 91 (expr -> WON OF expr AN expr .)
    STRING          reduce using rule 91 (expr -> WON OF expr AN expr .)
    FLOAT           reduce using rule 91 (expr -> WON OF expr AN expr .)
    INTEGER         reduce using rule 91 (expr -> WON OF expr AN expr .)
    WIN             reduce using rule 91 (expr -> WON OF expr AN expr .)
    FAIL            reduce using rule 91 (expr -> WON OF expr AN expr .)
    DICT            reduce using rule 91 (expr -> WON OF expr AN expr .)
    A               reduce using rule 91 (expr -> WON OF expr AN expr .)
    YARN            reduce using rule 91 (expr -> WON OF expr AN expr .)
    NUMBR           reduce using rule 91 (expr -> WON OF expr AN expr .)
    NUMBAR          reduce using rule 91 (expr -> WON OF expr AN expr .)
    NOOB            reduce using rule 91 (expr -> WON OF expr AN expr .)
    BUKKIT          reduce using rule 91 (expr -> WON OF expr AN expr .)
    EXCLAMATION     reduce using rule 91 (expr -> WON OF expr AN expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 91 (expr -> WON OF expr AN expr .) ]


state 212

    (39) declare_bukkit_block -> O HAI IM variable NEWLINE . statements KTHX
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 25
    statements                     shift and go to state 232
    statement                      shift and go to state 8
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    value                          shift and go to state 31

state 213

    (29) if_else -> O RLY QUESTION NEWLINE YA . RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> O RLY QUESTION NEWLINE YA . RLY NEWLINE statements OIC
    (31) if_else -> O RLY QUESTION NEWLINE YA . RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC

    RLY             shift and go to state 233


state 214

    (21) loop -> IM IN YR variable operation . YR variable condition expr NEWLINE statements IM OUTTA YR variable

    YR              shift and go to state 234


state 215

    (22) operation -> UPPIN .

    YR              reduce using rule 22 (operation -> UPPIN .)


state 216

    (23) operation -> NERFIN .

    YR              reduce using rule 23 (operation -> NERFIN .)


state 217

    (52) bukkit_function -> HOW IZ variable ID YR . sep_yr_args NEWLINE statements IF U SAY SO
    (50) sep_yr_args -> . sep_yr_args AN YR expr
    (51) sep_yr_args -> . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 90
    sep_yr_args                    shift and go to state 235
    expr                           shift and go to state 194
    value                          shift and go to state 31

state 218

    (53) bukkit_function -> HOW IZ variable ID NEWLINE . statements IF U SAY SO
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 25
    statements                     shift and go to state 236
    statement                      shift and go to state 8
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    value                          shift and go to state 31

state 219

    (54) function -> HOW IZ I ID YR . sep_yr_args NEWLINE statements IF U SAY SO
    (50) sep_yr_args -> . sep_yr_args AN YR expr
    (51) sep_yr_args -> . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    sep_yr_args                    shift and go to state 237
    expr                           shift and go to state 194
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 220

    (55) function -> HOW IZ I ID NEWLINE . statements IF U SAY SO
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    statements                     shift and go to state 238
    statement                      shift and go to state 8
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 221

    (28) export -> YOU CAN HAS sep_args MKAY .

    NEWLINE         reduce using rule 28 (export -> YOU CAN HAS sep_args MKAY .)
    COMMA           reduce using rule 28 (export -> YOU CAN HAS sep_args MKAY .)


state 222

    (27) import -> CAN HAS SNEK PATH QUESTION .

    NEWLINE         reduce using rule 27 (import -> CAN HAS SNEK PATH QUESTION .)
    COMMA           reduce using rule 27 (import -> CAN HAS SNEK PATH QUESTION .)


state 223

    (79) expr -> expr YR BASE ARE BELONG TO . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 239
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 224

    (58) expr -> variable IZ ID YR sep_yr_args MKAY .

    YR              reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    NEWLINE         reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    COMMA           reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    AN              reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    MKAY            reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    I               reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    SIZE            reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    ABSLUT          reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    BINRY           reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    SUM             reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    DIFF            reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    PRODUKT         reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    QUOSHUNT        reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    MOD             reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    BIGGR           reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    SMALLR          reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    BOTH            reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    EITHER          reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    WON             reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    NOT             reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    ALL             reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    ANY             reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    DIFFRINT        reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    SMOOSH          reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    MAEK            reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    ID              reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    IT              reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    STRING          reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    FLOAT           reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    INTEGER         reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    WIN             reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    FAIL            reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    DICT            reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    A               reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    YARN            reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    NUMBR           reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    NUMBAR          reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    NOOB            reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    BUKKIT          reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)
    EXCLAMATION     reduce using rule 58 (expr -> variable IZ ID YR sep_yr_args MKAY .)


state 225

    (50) sep_yr_args -> sep_yr_args AN . YR expr

    YR              shift and go to state 240


state 226

    (44) cast -> variable R MAEK variable A type .

    NEWLINE         reduce using rule 44 (cast -> variable R MAEK variable A type .)
    COMMA           reduce using rule 44 (cast -> variable R MAEK variable A type .)


state 227

    (40) assign_bukkit -> variable HAS A variable ITZ expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    NEWLINE         reduce using rule 40 (assign_bukkit -> variable HAS A variable ITZ expr .)
    COMMA           reduce using rule 40 (assign_bukkit -> variable HAS A variable ITZ expr .)
    YR              shift and go to state 67


state 228

    (56) expr -> I IZ ID YR sep_yr_args MKAY .

    YR              reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    NEWLINE         reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    COMMA           reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    AN              reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    MKAY            reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    I               reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    SIZE            reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    ABSLUT          reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    BINRY           reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    SUM             reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    DIFF            reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    PRODUKT         reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    QUOSHUNT        reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    MOD             reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    BIGGR           reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    SMALLR          reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    BOTH            reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    EITHER          reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    WON             reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    NOT             reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    ALL             reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    ANY             reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    DIFFRINT        reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    SMOOSH          reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    MAEK            reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    ID              reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    IT              reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    STRING          reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    FLOAT           reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    INTEGER         reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    WIN             reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    FAIL            reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    DICT            reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    A               reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    YARN            reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    NUMBR           reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    NUMBAR          reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    NOOB            reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    BUKKIT          reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)
    EXCLAMATION     reduce using rule 56 (expr -> I IZ ID YR sep_yr_args MKAY .)


state 229

    (37) decl -> I HAS A variable ITZ A . type
    (62) type -> . YARN
    (63) type -> . NUMBR
    (64) type -> . NUMBAR
    (65) type -> . NOOB
    (66) type -> . BUKKIT

    YARN            shift and go to state 143
    NUMBR           shift and go to state 144
    NUMBAR          shift and go to state 145
    NOOB            shift and go to state 146
    BUKKIT          shift and go to state 147

    type                           shift and go to state 241

state 230

    (36) decl -> I HAS A variable ITZ expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    NEWLINE         reduce using rule 36 (decl -> I HAS A variable ITZ expr .)
    COMMA           reduce using rule 36 (decl -> I HAS A variable ITZ expr .)
    YR              shift and go to state 67


state 231

    (38) decl -> I HAS A variable ITZ LIEK . A variable

    A               shift and go to state 242


state 232

    (39) declare_bukkit_block -> O HAI IM variable NEWLINE statements . KTHX
    (2) statements -> statements . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    KTHX            shift and go to state 243
    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 25
    statement                      shift and go to state 64
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    value                          shift and go to state 31

state 233

    (29) if_else -> O RLY QUESTION NEWLINE YA RLY . NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> O RLY QUESTION NEWLINE YA RLY . NEWLINE statements OIC
    (31) if_else -> O RLY QUESTION NEWLINE YA RLY . NEWLINE statements elifs NO WAI NEWLINE statements OIC

    NEWLINE         shift and go to state 244


state 234

    (21) loop -> IM IN YR variable operation YR . variable condition expr NEWLINE statements IM OUTTA YR variable
    (103) variable -> . ID
    (104) variable -> . IT

    ID              shift and go to state 27
    IT              shift and go to state 57

    variable                       shift and go to state 245

state 235

    (52) bukkit_function -> HOW IZ variable ID YR sep_yr_args . NEWLINE statements IF U SAY SO
    (50) sep_yr_args -> sep_yr_args . AN YR expr

    NEWLINE         shift and go to state 246
    AN              shift and go to state 225


state 236

    (53) bukkit_function -> HOW IZ variable ID NEWLINE statements . IF U SAY SO
    (2) statements -> statements . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    IF              shift and go to state 247
    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 25
    statement                      shift and go to state 64
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    value                          shift and go to state 31

state 237

    (54) function -> HOW IZ I ID YR sep_yr_args . NEWLINE statements IF U SAY SO
    (50) sep_yr_args -> sep_yr_args . AN YR expr

    NEWLINE         shift and go to state 248
    AN              shift and go to state 225


state 238

    (55) function -> HOW IZ I ID NEWLINE statements . IF U SAY SO
    (2) statements -> statements . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    IF              shift and go to state 249
    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    statement                      shift and go to state 64
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 239

    (79) expr -> expr YR BASE ARE BELONG TO expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

  ! shift/reduce conflict for YR resolved as shift
    NEWLINE         reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    COMMA           reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    AN              reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    MKAY            reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    I               reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    SIZE            reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    ABSLUT          reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    BINRY           reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    SUM             reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    DIFF            reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    PRODUKT         reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    QUOSHUNT        reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    MOD             reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    BIGGR           reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    SMALLR          reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    BOTH            reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    EITHER          reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    WON             reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    NOT             reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    ALL             reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    ANY             reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    DIFFRINT        reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    SMOOSH          reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    MAEK            reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    ID              reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    IT              reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    STRING          reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    FLOAT           reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    INTEGER         reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    WIN             reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    FAIL            reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    DICT            reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    A               reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    YARN            reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    NUMBR           reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    NUMBAR          reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    NOOB            reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    BUKKIT          reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    EXCLAMATION     reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .)
    YR              shift and go to state 67

  ! YR              [ reduce using rule 79 (expr -> expr YR BASE ARE BELONG TO expr .) ]


state 240

    (50) sep_yr_args -> sep_yr_args AN YR . expr
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 250
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 241

    (37) decl -> I HAS A variable ITZ A type .

    NEWLINE         reduce using rule 37 (decl -> I HAS A variable ITZ A type .)
    COMMA           reduce using rule 37 (decl -> I HAS A variable ITZ A type .)


state 242

    (38) decl -> I HAS A variable ITZ LIEK A . variable
    (103) variable -> . ID
    (104) variable -> . IT

    ID              shift and go to state 27
    IT              shift and go to state 57

    variable                       shift and go to state 251

state 243

    (39) declare_bukkit_block -> O HAI IM variable NEWLINE statements KTHX .

    NEWLINE         reduce using rule 39 (declare_bukkit_block -> O HAI IM variable NEWLINE statements KTHX .)
    COMMA           reduce using rule 39 (declare_bukkit_block -> O HAI IM variable NEWLINE statements KTHX .)


state 244

    (29) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE . statements NO WAI NEWLINE statements OIC
    (30) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE . statements OIC
    (31) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE . statements elifs NO WAI NEWLINE statements OIC
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    statements                     shift and go to state 252
    statement                      shift and go to state 8
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 245

    (21) loop -> IM IN YR variable operation YR variable . condition expr NEWLINE statements IM OUTTA YR variable
    (24) condition -> . TIL
    (25) condition -> . WILE

    TIL             shift and go to state 254
    WILE            shift and go to state 255

    condition                      shift and go to state 253

state 246

    (52) bukkit_function -> HOW IZ variable ID YR sep_yr_args NEWLINE . statements IF U SAY SO
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 25
    statements                     shift and go to state 256
    statement                      shift and go to state 8
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    value                          shift and go to state 31

state 247

    (53) bukkit_function -> HOW IZ variable ID NEWLINE statements IF . U SAY SO

    U               shift and go to state 257


state 248

    (54) function -> HOW IZ I ID YR sep_yr_args NEWLINE . statements IF U SAY SO
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    statements                     shift and go to state 258
    statement                      shift and go to state 8
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 249

    (55) function -> HOW IZ I ID NEWLINE statements IF . U SAY SO

    U               shift and go to state 259


state 250

    (50) sep_yr_args -> sep_yr_args AN YR expr .
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    MKAY            reduce using rule 50 (sep_yr_args -> sep_yr_args AN YR expr .)
    AN              reduce using rule 50 (sep_yr_args -> sep_yr_args AN YR expr .)
    NEWLINE         reduce using rule 50 (sep_yr_args -> sep_yr_args AN YR expr .)
    YR              shift and go to state 67


state 251

    (38) decl -> I HAS A variable ITZ LIEK A variable .

    NEWLINE         reduce using rule 38 (decl -> I HAS A variable ITZ LIEK A variable .)
    COMMA           reduce using rule 38 (decl -> I HAS A variable ITZ LIEK A variable .)


state 252

    (29) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements . NO WAI NEWLINE statements OIC
    (30) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements . OIC
    (31) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements . elifs NO WAI NEWLINE statements OIC
    (2) statements -> statements . statement
    (32) elifs -> . elifs elif
    (33) elifs -> . elif
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (34) elif -> . MEBBE expr NEWLINE statements
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NO              shift and go to state 260
    OIC             shift and go to state 261
    MEBBE           shift and go to state 264
    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    elifs                          shift and go to state 262
    statement                      shift and go to state 64
    elif                           shift and go to state 263
    command                        shift and go to state 9
    expr                           shift and go to state 11
    empty                          shift and go to state 10
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 253

    (21) loop -> IM IN YR variable operation YR variable condition . expr NEWLINE statements IM OUTTA YR variable
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 90
    expr                           shift and go to state 265
    value                          shift and go to state 31

state 254

    (24) condition -> TIL .

    I               reduce using rule 24 (condition -> TIL .)
    SIZE            reduce using rule 24 (condition -> TIL .)
    ABSLUT          reduce using rule 24 (condition -> TIL .)
    BINRY           reduce using rule 24 (condition -> TIL .)
    SUM             reduce using rule 24 (condition -> TIL .)
    DIFF            reduce using rule 24 (condition -> TIL .)
    PRODUKT         reduce using rule 24 (condition -> TIL .)
    QUOSHUNT        reduce using rule 24 (condition -> TIL .)
    MOD             reduce using rule 24 (condition -> TIL .)
    BIGGR           reduce using rule 24 (condition -> TIL .)
    SMALLR          reduce using rule 24 (condition -> TIL .)
    BOTH            reduce using rule 24 (condition -> TIL .)
    EITHER          reduce using rule 24 (condition -> TIL .)
    WON             reduce using rule 24 (condition -> TIL .)
    NOT             reduce using rule 24 (condition -> TIL .)
    ALL             reduce using rule 24 (condition -> TIL .)
    ANY             reduce using rule 24 (condition -> TIL .)
    DIFFRINT        reduce using rule 24 (condition -> TIL .)
    SMOOSH          reduce using rule 24 (condition -> TIL .)
    MAEK            reduce using rule 24 (condition -> TIL .)
    ID              reduce using rule 24 (condition -> TIL .)
    IT              reduce using rule 24 (condition -> TIL .)
    STRING          reduce using rule 24 (condition -> TIL .)
    FLOAT           reduce using rule 24 (condition -> TIL .)
    INTEGER         reduce using rule 24 (condition -> TIL .)
    WIN             reduce using rule 24 (condition -> TIL .)
    FAIL            reduce using rule 24 (condition -> TIL .)
    DICT            reduce using rule 24 (condition -> TIL .)


state 255

    (25) condition -> WILE .

    I               reduce using rule 25 (condition -> WILE .)
    SIZE            reduce using rule 25 (condition -> WILE .)
    ABSLUT          reduce using rule 25 (condition -> WILE .)
    BINRY           reduce using rule 25 (condition -> WILE .)
    SUM             reduce using rule 25 (condition -> WILE .)
    DIFF            reduce using rule 25 (condition -> WILE .)
    PRODUKT         reduce using rule 25 (condition -> WILE .)
    QUOSHUNT        reduce using rule 25 (condition -> WILE .)
    MOD             reduce using rule 25 (condition -> WILE .)
    BIGGR           reduce using rule 25 (condition -> WILE .)
    SMALLR          reduce using rule 25 (condition -> WILE .)
    BOTH            reduce using rule 25 (condition -> WILE .)
    EITHER          reduce using rule 25 (condition -> WILE .)
    WON             reduce using rule 25 (condition -> WILE .)
    NOT             reduce using rule 25 (condition -> WILE .)
    ALL             reduce using rule 25 (condition -> WILE .)
    ANY             reduce using rule 25 (condition -> WILE .)
    DIFFRINT        reduce using rule 25 (condition -> WILE .)
    SMOOSH          reduce using rule 25 (condition -> WILE .)
    MAEK            reduce using rule 25 (condition -> WILE .)
    ID              reduce using rule 25 (condition -> WILE .)
    IT              reduce using rule 25 (condition -> WILE .)
    STRING          reduce using rule 25 (condition -> WILE .)
    FLOAT           reduce using rule 25 (condition -> WILE .)
    INTEGER         reduce using rule 25 (condition -> WILE .)
    WIN             reduce using rule 25 (condition -> WILE .)
    FAIL            reduce using rule 25 (condition -> WILE .)
    DICT            reduce using rule 25 (condition -> WILE .)


state 256

    (52) bukkit_function -> HOW IZ variable ID YR sep_yr_args NEWLINE statements . IF U SAY SO
    (2) statements -> statements . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    IF              shift and go to state 266
    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 25
    statement                      shift and go to state 64
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    value                          shift and go to state 31

state 257

    (53) bukkit_function -> HOW IZ variable ID NEWLINE statements IF U . SAY SO

    SAY             shift and go to state 267


state 258

    (54) function -> HOW IZ I ID YR sep_yr_args NEWLINE statements . IF U SAY SO
    (2) statements -> statements . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    IF              shift and go to state 268
    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    statement                      shift and go to state 64
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 259

    (55) function -> HOW IZ I ID NEWLINE statements IF U . SAY SO

    SAY             shift and go to state 269


state 260

    (29) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO . WAI NEWLINE statements OIC

    WAI             shift and go to state 270


state 261

    (30) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC .

    NEWLINE         reduce using rule 30 (if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC .)
    COMMA           reduce using rule 30 (if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC .)


state 262

    (31) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs . NO WAI NEWLINE statements OIC
    (32) elifs -> elifs . elif
    (34) elif -> . MEBBE expr NEWLINE statements

    NO              shift and go to state 271
    MEBBE           shift and go to state 264

    elif                           shift and go to state 272

state 263

    (33) elifs -> elif .

    NO              reduce using rule 33 (elifs -> elif .)
    MEBBE           reduce using rule 33 (elifs -> elif .)


state 264

    (34) elif -> MEBBE . expr NEWLINE statements
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    I               shift and go to state 91
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 273
    variable                       shift and go to state 90
    value                          shift and go to state 31

state 265

    (21) loop -> IM IN YR variable operation YR variable condition expr . NEWLINE statements IM OUTTA YR variable
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    NEWLINE         shift and go to state 274
    YR              shift and go to state 67


state 266

    (52) bukkit_function -> HOW IZ variable ID YR sep_yr_args NEWLINE statements IF . U SAY SO

    U               shift and go to state 275


state 267

    (53) bukkit_function -> HOW IZ variable ID NEWLINE statements IF U SAY . SO

    SO              shift and go to state 276


state 268

    (54) function -> HOW IZ I ID YR sep_yr_args NEWLINE statements IF . U SAY SO

    U               shift and go to state 277


state 269

    (55) function -> HOW IZ I ID NEWLINE statements IF U SAY . SO

    SO              shift and go to state 278


state 270

    (29) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI . NEWLINE statements OIC

    NEWLINE         shift and go to state 279


state 271

    (31) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO . WAI NEWLINE statements OIC

    WAI             shift and go to state 280


state 272

    (32) elifs -> elifs elif .

    NO              reduce using rule 32 (elifs -> elifs elif .)
    MEBBE           reduce using rule 32 (elifs -> elifs elif .)


state 273

    (34) elif -> MEBBE expr . NEWLINE statements
    (79) expr -> expr . YR BASE ARE BELONG TO expr

    NEWLINE         shift and go to state 281
    YR              shift and go to state 67


state 274

    (21) loop -> IM IN YR variable operation YR variable condition expr NEWLINE . statements IM OUTTA YR variable
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 25
    expr                           shift and go to state 11
    statements                     shift and go to state 282
    statement                      shift and go to state 8
    command                        shift and go to state 9
    empty                          shift and go to state 10
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    value                          shift and go to state 31

state 275

    (52) bukkit_function -> HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U . SAY SO

    SAY             shift and go to state 283


state 276

    (53) bukkit_function -> HOW IZ variable ID NEWLINE statements IF U SAY SO .

    NEWLINE         reduce using rule 53 (bukkit_function -> HOW IZ variable ID NEWLINE statements IF U SAY SO .)
    COMMA           reduce using rule 53 (bukkit_function -> HOW IZ variable ID NEWLINE statements IF U SAY SO .)


state 277

    (54) function -> HOW IZ I ID YR sep_yr_args NEWLINE statements IF U . SAY SO

    SAY             shift and go to state 284


state 278

    (55) function -> HOW IZ I ID NEWLINE statements IF U SAY SO .

    NEWLINE         reduce using rule 55 (function -> HOW IZ I ID NEWLINE statements IF U SAY SO .)
    COMMA           reduce using rule 55 (function -> HOW IZ I ID NEWLINE statements IF U SAY SO .)


state 279

    (29) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE . statements OIC
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    statements                     shift and go to state 285
    statement                      shift and go to state 8
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 280

    (31) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI . NEWLINE statements OIC

    NEWLINE         shift and go to state 286


state 281

    (34) elif -> MEBBE expr NEWLINE . statements
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 11
    statements                     shift and go to state 287
    statement                      shift and go to state 8
    command                        shift and go to state 9
    empty                          shift and go to state 10
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 282

    (21) loop -> IM IN YR variable operation YR variable condition expr NEWLINE statements . IM OUTTA YR variable
    (2) statements -> statements . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    IM              shift and go to state 288
    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    variable                       shift and go to state 25
    expr                           shift and go to state 11
    statement                      shift and go to state 64
    command                        shift and go to state 9
    empty                          shift and go to state 10
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    value                          shift and go to state 31

state 283

    (52) bukkit_function -> HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY . SO

    SO              shift and go to state 289


state 284

    (54) function -> HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY . SO

    SO              shift and go to state 290


state 285

    (29) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements . OIC
    (2) statements -> statements . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    OIC             shift and go to state 291
    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    statement                      shift and go to state 64
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 286

    (31) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE . statements OIC
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    statements                     shift and go to state 292
    statement                      shift and go to state 8
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 287

    (34) elif -> MEBBE expr NEWLINE statements .
    (2) statements -> statements . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    NO              reduce using rule 34 (elif -> MEBBE expr NEWLINE statements .)
    MEBBE           reduce using rule 34 (elif -> MEBBE expr NEWLINE statements .)
    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    expr                           shift and go to state 11
    statement                      shift and go to state 64
    command                        shift and go to state 9
    empty                          shift and go to state 10
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 288

    (21) loop -> IM IN YR variable operation YR variable condition expr NEWLINE statements IM . OUTTA YR variable
    (21) loop -> IM . IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable

    OUTTA           shift and go to state 293
    IN              shift and go to state 104


state 289

    (52) bukkit_function -> HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO .

    NEWLINE         reduce using rule 52 (bukkit_function -> HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO .)
    COMMA           reduce using rule 52 (bukkit_function -> HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO .)


state 290

    (54) function -> HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO .

    NEWLINE         reduce using rule 54 (function -> HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO .)
    COMMA           reduce using rule 54 (function -> HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO .)


state 291

    (29) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC .

    NEWLINE         reduce using rule 29 (if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC .)
    COMMA           reduce using rule 29 (if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC .)


state 292

    (31) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements . OIC
    (2) statements -> statements . statement
    (4) statement -> . command NEWLINE
    (5) statement -> . command COMMA
    (6) command -> . empty
    (7) command -> . expr
    (8) command -> . call
    (9) command -> . cast
    (10) command -> . decl
    (11) command -> . assign_bukkit
    (12) command -> . assign
    (13) command -> . declare_bukkit_block
    (14) command -> . if_else
    (15) command -> . bukkit_function
    (16) command -> . function
    (17) command -> . return
    (18) command -> . loop
    (19) command -> . export
    (20) command -> . import
    (106) empty -> .
    (42) expr -> . variable APOSTROPHE_Z variable
    (56) expr -> . I IZ ID YR sep_yr_args MKAY
    (57) expr -> . I IZ ID
    (58) expr -> . variable IZ ID YR sep_yr_args MKAY
    (59) expr -> . variable IZ ID
    (76) expr -> . SIZE OF expr
    (77) expr -> . ABSLUT OF expr
    (78) expr -> . BINRY OF expr
    (79) expr -> . expr YR BASE ARE BELONG TO expr
    (80) expr -> . value
    (81) expr -> . variable
    (82) expr -> . SUM OF expr AN expr
    (83) expr -> . DIFF OF expr AN expr
    (84) expr -> . PRODUKT OF expr AN expr
    (85) expr -> . QUOSHUNT OF expr AN expr
    (86) expr -> . MOD OF expr AN expr
    (87) expr -> . BIGGR OF expr AN expr
    (88) expr -> . SMALLR OF expr AN expr
    (89) expr -> . BOTH OF expr AN expr
    (90) expr -> . EITHER OF expr AN expr
    (91) expr -> . WON OF expr AN expr
    (92) expr -> . NOT expr
    (93) expr -> . ALL OF sep_args MKAY
    (94) expr -> . ANY OF sep_args MKAY
    (95) expr -> . ALL OF args MKAY
    (96) expr -> . ANY OF args MKAY
    (97) expr -> . BOTH SAEM expr AN expr
    (98) expr -> . DIFFRINT expr AN expr
    (99) expr -> . SMOOSH sep_args MKAY
    (100) expr -> . SMOOSH args MKAY
    (101) expr -> . MAEK expr A type
    (102) expr -> . MAEK expr type
    (73) call -> . VISIBLE args
    (74) call -> . VISIBLE args EXCLAMATION
    (75) call -> . GIMMEH variable
    (43) cast -> . variable IS NOW A type
    (44) cast -> . variable R MAEK variable A type
    (45) cast -> . variable R MAEK variable type
    (35) decl -> . I HAS A variable
    (36) decl -> . I HAS A variable ITZ expr
    (37) decl -> . I HAS A variable ITZ A type
    (38) decl -> . I HAS A variable ITZ LIEK A variable
    (40) assign_bukkit -> . variable HAS A variable ITZ expr
    (41) assign -> . variable R expr
    (39) declare_bukkit_block -> . O HAI IM variable NEWLINE statements KTHX
    (29) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements NO WAI NEWLINE statements OIC
    (30) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements OIC
    (31) if_else -> . O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC
    (52) bukkit_function -> . HOW IZ variable ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (53) bukkit_function -> . HOW IZ variable ID NEWLINE statements IF U SAY SO
    (54) function -> . HOW IZ I ID YR sep_yr_args NEWLINE statements IF U SAY SO
    (55) function -> . HOW IZ I ID NEWLINE statements IF U SAY SO
    (60) return -> . FOUND YR expr
    (61) return -> . GTFO
    (21) loop -> . IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable
    (28) export -> . YOU CAN HAS sep_args MKAY
    (26) import -> . CAN HAS PATH QUESTION
    (27) import -> . CAN HAS SNEK PATH QUESTION
    (103) variable -> . ID
    (104) variable -> . IT
    (67) value -> . STRING
    (68) value -> . FLOAT
    (69) value -> . INTEGER
    (70) value -> . WIN
    (71) value -> . FAIL
    (72) value -> . DICT

    OIC             shift and go to state 294
    NEWLINE         reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    I               shift and go to state 26
    SIZE            shift and go to state 28
    ABSLUT          shift and go to state 29
    BINRY           shift and go to state 30
    SUM             shift and go to state 32
    DIFF            shift and go to state 33
    PRODUKT         shift and go to state 34
    QUOSHUNT        shift and go to state 35
    MOD             shift and go to state 36
    BIGGR           shift and go to state 37
    SMALLR          shift and go to state 38
    BOTH            shift and go to state 39
    EITHER          shift and go to state 40
    WON             shift and go to state 41
    NOT             shift and go to state 42
    ALL             shift and go to state 43
    ANY             shift and go to state 44
    DIFFRINT        shift and go to state 45
    SMOOSH          shift and go to state 46
    MAEK            shift and go to state 47
    VISIBLE         shift and go to state 48
    GIMMEH          shift and go to state 49
    O               shift and go to state 50
    HOW             shift and go to state 52
    FOUND           shift and go to state 53
    GTFO            shift and go to state 54
    IM              shift and go to state 51
    YOU             shift and go to state 55
    CAN             shift and go to state 56
    ID              shift and go to state 27
    IT              shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 6
    INTEGER         shift and go to state 59
    WIN             shift and go to state 60
    FAIL            shift and go to state 61
    DICT            shift and go to state 62

    statement                      shift and go to state 64
    command                        shift and go to state 9
    empty                          shift and go to state 10
    expr                           shift and go to state 11
    call                           shift and go to state 12
    cast                           shift and go to state 13
    decl                           shift and go to state 14
    assign_bukkit                  shift and go to state 15
    assign                         shift and go to state 16
    declare_bukkit_block           shift and go to state 17
    if_else                        shift and go to state 18
    bukkit_function                shift and go to state 19
    function                       shift and go to state 20
    return                         shift and go to state 21
    loop                           shift and go to state 22
    export                         shift and go to state 23
    import                         shift and go to state 24
    variable                       shift and go to state 25
    value                          shift and go to state 31

state 293

    (21) loop -> IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA . YR variable

    YR              shift and go to state 295


state 294

    (31) if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC .

    NEWLINE         reduce using rule 31 (if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC .)
    COMMA           reduce using rule 31 (if_else -> O RLY QUESTION NEWLINE YA RLY NEWLINE statements elifs NO WAI NEWLINE statements OIC .)


state 295

    (21) loop -> IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR . variable
    (103) variable -> . ID
    (104) variable -> . IT

    ID              shift and go to state 27
    IT              shift and go to state 57

    variable                       shift and go to state 296

state 296

    (21) loop -> IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable .

    NEWLINE         reduce using rule 21 (loop -> IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable .)
    COMMA           reduce using rule 21 (loop -> IM IN YR variable operation YR variable condition expr NEWLINE statements IM OUTTA YR variable .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for YR in state 89 resolved as shift
WARNING: shift/reduce conflict for YR in state 111 resolved as shift
WARNING: shift/reduce conflict for YR in state 116 resolved as shift
WARNING: shift/reduce conflict for YR in state 118 resolved as shift
WARNING: shift/reduce conflict for YR in state 119 resolved as shift
WARNING: shift/reduce conflict for YR in state 120 resolved as shift
WARNING: shift/reduce conflict for A in state 161 resolved as shift
WARNING: shift/reduce conflict for YARN in state 161 resolved as shift
WARNING: shift/reduce conflict for NUMBR in state 161 resolved as shift
WARNING: shift/reduce conflict for NUMBAR in state 161 resolved as shift
WARNING: shift/reduce conflict for NOOB in state 161 resolved as shift
WARNING: shift/reduce conflict for BUKKIT in state 161 resolved as shift
WARNING: shift/reduce conflict for YR in state 180 resolved as shift
WARNING: shift/reduce conflict for YR in state 201 resolved as shift
WARNING: shift/reduce conflict for YR in state 202 resolved as shift
WARNING: shift/reduce conflict for YR in state 203 resolved as shift
WARNING: shift/reduce conflict for YR in state 204 resolved as shift
WARNING: shift/reduce conflict for YR in state 205 resolved as shift
WARNING: shift/reduce conflict for YR in state 206 resolved as shift
WARNING: shift/reduce conflict for YR in state 207 resolved as shift
WARNING: shift/reduce conflict for YR in state 208 resolved as shift
WARNING: shift/reduce conflict for YR in state 209 resolved as shift
WARNING: shift/reduce conflict for YR in state 210 resolved as shift
WARNING: shift/reduce conflict for YR in state 211 resolved as shift
WARNING: shift/reduce conflict for YR in state 239 resolved as shift
WARNING: reduce/reduce conflict in state 97 resolved using rule (args -> expr)
WARNING: rejected rule (sep_args -> expr) in state 97
